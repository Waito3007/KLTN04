# ==================================================
# Path: D:\Project\KLTN04
# Detected tech: javascript, python, react, rust, typescript
# ==================================================

## DIRECTORY STRUCTURE
```
KLTN04/
‚îú‚îÄ‚îÄ .git/
‚îú‚îÄ‚îÄ .venv/
‚îú‚îÄ‚îÄ backend/
‚îÇ   ‚îú‚îÄ‚îÄ __pycache__/
‚îÇ   ‚îú‚îÄ‚îÄ ai/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ modelAi/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ner/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cfg
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ model
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ moves
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ textcat/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cfg
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ model
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ textcat_multilabel/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cfg
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ model
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ vocab/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ key2row
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ lookups.bin
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ strings.json
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ vectors
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ vectors.cfg
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config.cfg
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ generate_data.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ meta.json
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ tokenizer
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ predict.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ subintent_keywords.json
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ test_model.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ train_data.json
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ train_spacy.py
‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __pycache__/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __pycache__/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ai_suggestions.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ commit_routes.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ github.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ gitlab.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ repo.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ users.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ deps.py
‚îÇ   ‚îú‚îÄ‚îÄ core/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __pycache__/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ lifespan.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ logger.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ oauth.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ security.py
‚îÇ   ‚îú‚îÄ‚îÄ db/
‚îÇ   ‚îú‚îÄ‚îÄ migrations/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ README
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ env.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ script.py.mako
‚îÇ   ‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __pycache__/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ commit_classifier.joblib
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ commit_classifier_v1.joblib
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ commit_model.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ task_model.py
‚îÇ   ‚îú‚îÄ‚îÄ notebooks/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Model_Training.ipynb
‚îÇ   ‚îú‚îÄ‚îÄ schemas/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __pycache__/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ commit.py
‚îÇ   ‚îú‚îÄ‚îÄ scripts/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ commit_analysis_system.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ commit_analysis_system_v1.py
‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __pycache__/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ai_model.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ai_service.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ branch_service.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ commit_service.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ github_service.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ gitlab_service.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ issue_service.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ model_loader.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ repo_service.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ report_generator.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ user_service.py
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ formatter.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ scheduler.py
‚îÇ   ‚îú‚îÄ‚îÄ .env
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ alembic.ini
‚îÇ   ‚îú‚îÄ‚îÄ main.py
‚îÇ   ‚îî‚îÄ‚îÄ requirements.txt
‚îú‚îÄ‚îÄ frontend/
‚îÇ   ‚îú‚îÄ‚îÄ node_modules/
‚îÇ   ‚îú‚îÄ‚îÄ public/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ vite.svg
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ github.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ assets/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ react.svg
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Branchs/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ BranchSelector.jsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Dashboard/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AIInsightWidget.jsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ OverviewCard.jsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ RepoListFilter.jsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ TaskBoard.jsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ commits/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AnalyzeGitHubCommits.jsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CommitAnalysisBadge.jsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CommitAnalysisModal.jsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CommitList.jsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CommitTable.jsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ repo/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ RepoList.jsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ features/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ github/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ GithubRepoFetcher.jsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ pages/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AuthSuccess.jsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Dashboard.jsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Login.jsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ RepoDetails.jsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ types.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ App.css
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ App.jsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.css
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ main.jsx
‚îÇ   ‚îú‚îÄ‚îÄ .gitignore
‚îÇ   ‚îú‚îÄ‚îÄ README.md
‚îÇ   ‚îú‚îÄ‚îÄ eslint.config.js
‚îÇ   ‚îú‚îÄ‚îÄ index.html
‚îÇ   ‚îú‚îÄ‚îÄ package-lock.json
‚îÇ   ‚îú‚îÄ‚îÄ package.json
‚îÇ   ‚îî‚îÄ‚îÄ vite.config.js
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ Backend.txt
‚îú‚îÄ‚îÄ Frontend.txt
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ poetry.lock
‚îî‚îÄ‚îÄ pyproject.toml
```

## FILE CONTENTS

### backend\main.py
```py
# backend/main.py
from fastapi import FastAPI
from core.lifespan import lifespan
from core.config import setup_middlewares
from core.logger import setup_logger
from core.config import setup_middlewares, setup_routers
from services.ai_service import router as ai_router
from api.routes.commit_routes import router as commit_router

from api.routes.auth import auth_router
from api.routes.github import github_router

setup_logger()  # B·∫≠t logger tr∆∞·ªõc khi ch·∫°y app


app = FastAPI(lifespan=lifespan)

setup_routers(app)

setup_middlewares(app)

# Include routers tr·ª±c ti·∫øp
app.include_router(auth_router, prefix="/api")
app.include_router(github_router, prefix="/api")
app.include_router(ai_router, prefix="/ai")
app.include_router(commit_router)

@app.get("/")
def root():
    return {"message": "TaskFlowAI backend is running "}

```

### backend\__init__.py
```py

```

### backend\ai\predict.py
```py
# G·ªçi m√¥ h√¨nh ƒë·ªÉ ph√¢n lo·∫°i message
```

### backend\ai\test_model.py
```py
import spacy

# Load m√¥ h√¨nh ƒë√£ train
nlp = spacy.load("modelAi")

# C√°c c√¢u commit c·∫ßn test
texts = [
    "feat: Th√™m t√≠nh nƒÉng x·ª≠ l√Ω l·ªói",
    "fix: S·ª≠a l·ªói hi·ªÉn th·ªã tr√™n giao di·ªán ng∆∞·ªùi d√πng",
    "docs: C·∫≠p nh·∫≠t t√†i li·ªáu API",
    "refactor: T·ªëi ∆∞u code module t√¨m ki·∫øm",
    "style: Ch·ªânh s·ª≠a format code",
    "test: Th√™m test case cho h√†m login",
    "chore: C·∫≠p nh·∫≠t dependencies",
    "uncategorized: Thay ƒë·ªïi c·∫•u tr√∫c th∆∞ m·ª•c",
    "feat: Th√™m API thanh to√°n m·ªõi",
    "fix: S·ª≠a layout b·ªã c√°ch ra ngo√†i",
]

for text in texts:
    doc = nlp(text)
    print(f"VƒÉn b·∫£n: {text}")
    for label, score in doc.cats.items():
        if score > 0.05:  # T√πy ch·ªânh ng∆∞·ª°ng l·ªçc nh√£n
            print(f"{label}: {score:.4f}")
    print()

```

### backend\ai\train_spacy.py
```py
import spacy
from spacy.training.example import Example
import random
import json

# T·∫£i m√¥ h√¨nh ƒëa ng√¥n ng·ªØ
nlp = spacy.load("xx_ent_wiki_sm")

# Th√™m textcat_multilabel v√†o pipeline n·∫øu ch∆∞a c√≥
if "textcat_multilabel" not in nlp.pipe_names:
    textcat = nlp.add_pipe("textcat_multilabel", last=True)
else:
    textcat = nlp.get_pipe("textcat_multilabel")

# Th√™m c√°c nh√£n
labels = ["feat", "fix", "docs", "style", "refactor", "chore", "test", "uncategorized",
          "auth", "search", "cart", "order", "profile", "product", "api", "ui", "notification", "dashboard"]

for label in labels:
    textcat.add_label(label)

# ƒê·ªçc d·ªØ li·ªáu t·ª´ file JSON
with open('train_data.json', 'r', encoding='utf-8') as f:
    data = json.load(f)

train_data = []
for entry in data:
    text = entry["text"]
    cats = entry["cats"]
    example = Example.from_dict(nlp.make_doc(text), {"cats": cats})
    train_data.append(example)

optimizer = nlp.begin_training()
for epoch in range(10):
    random.shuffle(train_data)
    losses = {}
    for example in train_data:
        nlp.update([example], losses=losses)
    print(f"Epoch {epoch} - Losses: {losses}")

output_dir = "modelAi"
nlp.to_disk(output_dir)
print(f"Model saved to {output_dir}")

```

### backend\ai\__init__.py
```py

```

### backend\ai\modelAi\generate_data.py
```py
import json
from db.database import database
from db.models.commits import commits  # ƒê·∫£m b·∫£o b·∫°n ƒë√£ import ƒë√∫ng model commits
from datetime import datetime

# H√†m ƒë·ªÉ chuy·ªÉn d·ªØ li·ªáu commit th√†nh ƒë·ªãnh d·∫°ng spaCy
async def convert_to_spacy_format():
    # K·∫øt n·ªëi c∆° s·ªü d·ªØ li·ªáu tr∆∞·ªõc khi truy v·∫•n
    await database.connect()

    # Truy v·∫•n t·∫•t c·∫£ d·ªØ li·ªáu commits t·ª´ database
    query = commits.select()  # Thay ƒë·ªïi n·∫øu b·∫°n s·ª≠ d·ª•ng ORM kh√°c nh∆∞ SQLAlchemy
    rows = await database.fetch_all(query)

    # Danh s√°ch ƒë·ªÉ l∆∞u d·ªØ li·ªáu theo ƒë·ªãnh d·∫°ng spaCy
    data = []

    for row in rows:
        # L·∫•y d·ªØ li·ªáu t·ª´ commit
        sha = row["sha"]
        message = row["message"]  # L·∫•y tr∆∞·ªùng 'message' t·ª´ commit
        author_name = row["author_name"]
        author_email = row["author_email"]
        date = row["date"]  # Tr∆∞·ªùng ng√†y gi·ªù commit
        insertions = row["insertions"]
        deletions = row["deletions"]
        files_changed = row["files_changed"]
        repo_id = row["repo_id"]

        # N·∫øu date l√† ki·ªÉu datetime, chuy·ªÉn n√≥ th√†nh chu·ªói
        if isinstance(date, datetime):
            date = date.strftime('%Y-%m-%d %H:%M:%S')  # Chuy·ªÉn ƒë·ªïi theo ƒë·ªãnh d·∫°ng mong mu·ªën
        
        # Ki·ªÉm tra commit c√≥ ch·ª©a tr∆∞·ªùng message hay kh√¥ng
        if message:
            # Ph√¢n lo·∫°i label t·ª´ message
            label = get_label_from_message(message)

            # Th√™m v√†o danh s√°ch data v·ªõi ƒë·ªãnh d·∫°ng spaCy
            data.append({
                "text": message,  # N·ªôi dung commit
                "meta": {
                    "sha": sha,  # SHA c·ªßa commit
                    "author_name": author_name,  # T√™n t√°c gi·∫£
                    "author_email": author_email,  # Email t√°c gi·∫£
                    "date": date,  # Ng√†y commit (chu·ªói)
                    "insertions": insertions,  # S·ªë d√≤ng th√™m
                    "deletions": deletions,  # S·ªë d√≤ng x√≥a
                    "files_changed": files_changed,  # S·ªë file thay ƒë·ªïi
                    "repo_id": repo_id  # ID c·ªßa repository
                },
                "cats": label  # Th·∫ª ph√¢n lo·∫°i c·ªßa commit
            })

    # Ghi d·ªØ li·ªáu ra file JSON cho spaCy
    with open("ai/train_data.json", "w", encoding="utf-8") as f:
        json.dump(data, f, ensure_ascii=False, indent=2)

    print("D·ªØ li·ªáu ƒë√£ ƒë∆∞·ª£c chuy·ªÉn th√†nh c√¥ng!")

    # Ng·∫Øt k·∫øt n·ªëi c∆° s·ªü d·ªØ li·ªáu sau khi ho√†n th√†nh
    await database.disconnect()

# H√†m ph√¢n lo·∫°i label t·ª´ message (c·∫ßn ph·∫£i vi·∫øt logic ph√¢n lo·∫°i c·ªßa b·∫°n)
def get_label_from_message(message):
    # C√°c t·ª´ kh√≥a ph·ªï bi·∫øn trong commit
    categories = {
        "feat": {"feat": 1.0, "fix": 0.0, "docs": 0.0, "style": 0.0, "refactor": 0.0, "chore": 0.0, "test": 0.0},
        "th√™m": {"feat": 1.0, "fix": 0.0, "docs": 0.0, "style": 0.0, "refactor": 0.0, "chore": 0.0, "test": 0.0},
        "fix": {"feat": 0.0, "fix": 1.0, "docs": 0.0, "style": 0.0, "refactor": 0.0, "chore": 0.0, "test": 0.0},
        "s·ª≠a": {"feat": 0.0, "fix": 1.0, "docs": 0.0, "style": 0.0, "refactor": 0.0, "chore": 0.0, "test": 0.0},
        "docs": {"feat": 0.0, "fix": 0.0, "docs": 1.0, "style": 0.0, "refactor": 0.0, "chore": 0.0, "test": 0.0},
        "style": {"feat": 0.0, "fix": 0.0, "docs": 0.0, "style": 1.0, "refactor": 0.0, "chore": 0.0, "test": 0.0},
        "refactor": {"feat": 0.0, "fix": 0.0, "docs": 0.0, "style": 0.0, "refactor": 1.0, "chore": 0.0, "test": 0.0},
        "chore": {"feat": 0.0, "fix": 0.0, "docs": 0.0, "style": 0.0, "refactor": 0.0, "chore": 1.0, "test": 0.0},
        "test": {"feat": 0.0, "fix": 0.0, "docs": 0.0, "style": 0.0, "refactor": 0.0, "chore": 0.0, "test": 1.0},
    }

    # Ki·ªÉm tra n·∫øu commit ch·ª©a m·ªôt trong c√°c t·ª´ kh√≥a tr√™n
    for keyword, label in categories.items():
        if keyword in message.lower():
            return label
    
    # N·∫øu kh√¥ng c√≥ t·ª´ kh√≥a n√†o trong message, ph√¢n lo·∫°i l√† 'uncategorized'
    return {"feat": 0.0, "fix": 0.0, "docs": 0.0, "style": 0.0, "refactor": 0.0, "chore": 0.0, "test": 0.0, "uncategorized": 1.0}

# Ch·∫°y h√†m convert_to_spacy_format
if __name__ == "__main__":
    import asyncio
    asyncio.run(convert_to_spacy_format())

```

### backend\api\deps.py
```py
# KLTN04\backend\api\deps.py
# File ch·ª©a c√°c dependencies (ph·ª• thu·ªôc) chung c·ªßa ·ª©ng d·ª•ng

# Import AsyncSession t·ª´ SQLAlchemy ƒë·ªÉ l√†m vi·ªác v·ªõi database async
from sqlalchemy.ext.asyncio import AsyncSession

# Import k·∫øt n·ªëi database t·ª´ module database
from db.database import database

# Dependency (ph·ª• thu·ªôc) ƒë·ªÉ l·∫•y database session
async def get_db() -> AsyncSession:
    """
    Dependency t·∫°o v√† qu·∫£n l√Ω database session
    
    C√°ch ho·∫°t ƒë·ªông:
    - T·∫°o m·ªôt async session m·ªõi t·ª´ connection pool
    - Yield session ƒë·ªÉ s·ª≠ d·ª•ng trong request
    - ƒê·∫£m b·∫£o session ƒë∆∞·ª£c ƒë√≥ng sau khi request ho√†n th√†nh
    
    Returns:
        AsyncSession: Session database async ƒë·ªÉ t∆∞∆°ng t√°c v·ªõi DB
    """
    # T·∫°o v√† qu·∫£n l√Ω session th√¥ng qua context manager
    async with database.session() as session:
        # Yield session ƒë·ªÉ s·ª≠ d·ª•ng trong route
        yield session
        # Session s·∫Ω t·ª± ƒë·ªông ƒë√≥ng khi ra kh·ªèi block with
```

### backend\api\__init__.py
```py

```

### backend\api\routes\ai_suggestions.py
```py

```

### backend\api\routes\auth.py
```py
# KLTN04\backend\api\routes\auth.py
from fastapi import APIRouter, Request, HTTPException
from core.oauth import oauth
from fastapi.responses import RedirectResponse
from services.user_service import save_user  # Import h√†m l∆∞u ng∆∞·ªùi d√πng
import os

auth_router = APIRouter()

# Endpoint /login ƒë·ªÉ b·∫Øt ƒë·∫ßu qu√° tr√¨nh x√°c th·ª±c v·ªõi GitHub
@auth_router.get("/login")
async def login(request: Request):
    # L·∫•y callback URL t·ª´ bi·∫øn m√¥i tr∆∞·ªùng
    redirect_uri = os.getenv("GITHUB_CALLBACK_URL")
    
    # Chuy·ªÉn h∆∞·ªõng ng∆∞·ªùi d√πng ƒë·∫øn trang x√°c th·ª±c GitHub
    return await oauth.github.authorize_redirect(request, redirect_uri)

# Endpoint /auth/callback - GitHub s·∫Ω g·ªçi l·∫°i endpoint n√†y sau khi x√°c th·ª±c th√†nh c√¥ng
@auth_router.get("/auth/callback")
async def auth_callback(request: Request):
    code = request.query_params.get("code")
    if not code:
        raise HTTPException(status_code=400, detail="Missing code")

    # L·∫•y access token t·ª´ GitHub
    token = await oauth.github.authorize_access_token(request)
    
    # G·ªçi API GitHub ƒë·ªÉ l·∫•y th√¥ng tin user c∆° b·∫£n
    resp = await oauth.github.get("user", token=token)
    profile = resp.json()  # Chuy·ªÉn response th√†nh dictionary

    # L·∫•y email n·∫øu kh√¥ng c√≥ trong profile
    if not profile.get("email"):
        # G·ªçi API ri√™ng ƒë·ªÉ l·∫•y danh s√°ch email
        emails_resp = await oauth.github.get("user/emails", token=token)
        emails = emails_resp.json()
        
        # T√¨m email ƒë∆∞·ª£c ƒë√°nh d·∫•u l√† primary (ch√≠nh)
        primary_email = next((e["email"] for e in emails if e["primary"]), None)
        
        # G√°n email ch√≠nh v√†o profile
        profile["email"] = primary_email

    # Ki·ªÉm tra th√¥ng tin b·∫Øt bu·ªôc
    if not profile.get("email") or not profile.get("login"):
        raise HTTPException(status_code=400, detail="Missing required user information")

    # L∆∞u th√¥ng tin ng∆∞·ªùi d√πng v√†o c∆° s·ªü d·ªØ li·ªáu
    user_data = {
        "github_id": profile["id"],
        "github_username": profile["login"],
        "email": profile["email"],
        "avatar_url": profile["avatar_url"],
    }
    await save_user(user_data)

    # Redirect v·ªÅ frontend v·ªõi token v√† th√¥ng tin ng∆∞·ªùi d√πng
    redirect_url = (
        f"http://localhost:5173/auth-success"
        f"?token={token['access_token']}"
        f"&username={profile['login']}"
        f"&email={profile['email']}"
        f"&avatar_url={profile['avatar_url']}"
    )

    # Th·ª±c hi·ªán chuy·ªÉn h∆∞·ªõng v·ªÅ frontend
    return RedirectResponse(redirect_url)
```

### backend\api\routes\commit_routes.py
```py
# File: backend/api/routes/commit_routes.py
from fastapi import APIRouter, HTTPException, UploadFile, File, Header
from fastapi.responses import JSONResponse
from typing import List, Optional
import pandas as pd
from services.model_loader import predict_commit
from pathlib import Path
import tempfile
import httpx

router = APIRouter(prefix="/api/commits", tags=["Commit Analysis"])

@router.get("/analyze-github/{owner}/{repo}")
async def analyze_github_commits(
    owner: str,
    repo: str,
    authorization: str = Header(..., alias="Authorization"),
    per_page: int = 30,
    since: Optional[str] = None,
    until: Optional[str] = None
):
    """
    Ph√¢n t√≠ch commit t·ª´ repository GitHub
    
    Args:
        owner: T√™n ch·ªß repo
        repo: T√™n repository
        authorization: Token GitHub (Format: Bearer <token>)
        per_page: S·ªë commit t·ªëi ƒëa c·∫ßn ph√¢n t√≠ch (1-100)
        since: L·ªçc commit t·ª´ ng√†y (YYYY-MM-DDTHH:MM:SSZ)
        until: L·ªçc commit ƒë·∫øn ng√†y (YYYY-MM-DDTHH:MM:SSZ)
    
    Returns:
        {
            "repo": f"{owner}/{repo}",
            "total": int,
            "critical": int,
            "critical_percentage": float,
            "details": List[dict],
            "analysis_date": str
        }
    """
    try:
        # Validate input
        if per_page < 1 or per_page > 100:
            raise HTTPException(
                status_code=400,
                detail="per_page must be between 1 and 100"
            )

        # Configure GitHub API request
        headers = {
            "Authorization": authorization,
            "Accept": "application/vnd.github.v3+json"
        }
        params = {
            "per_page": per_page,
            "since": since,
            "until": until
        }
        
        # Fetch commits from GitHub
        async with httpx.AsyncClient() as client:
            # Get first page to check repo accessibility
            initial_url = f"https://api.github.com/repos/{owner}/{repo}/commits"
            response = await client.get(initial_url, headers=headers, params={**params, "per_page": 1})
            
            if response.status_code == 404:
                raise HTTPException(
                    status_code=404,
                    detail="Repository not found or access denied"
                )
            response.raise_for_status()

            # Get all requested commits
            full_url = f"https://api.github.com/repos/{owner}/{repo}/commits"
            response = await client.get(full_url, headers=headers, params=params)
            response.raise_for_status()
            commits_data = response.json()

        # Prepare analysis data
        commits_for_analysis = [
            {
                "id": commit["sha"],
                "message": commit["commit"]["message"],
                "date": commit["commit"]["committer"]["date"] if commit["commit"]["committer"] else None
            }
            for commit in commits_data
            if commit.get("sha") and commit.get("commit", {}).get("message")
        ]

        # Analyze commits
        results = {
            "repo": f"{owner}/{repo}",
            "total": len(commits_for_analysis),
            "critical": 0,
            "critical_percentage": 0.0,
            "details": [],
            "analysis_date": datetime.utcnow().isoformat()
        }

        for commit in commits_for_analysis:
            is_critical = predict_commit(commit['message'])
            if is_critical:
                results["critical"] += 1
            
            results["details"].append({
                "id": commit["id"],
                "is_critical": is_critical,
                "message_preview": commit['message'][:100] + "..." if len(commit['message']) > 100 else commit['message'],
                "date": commit["date"]
            })

        # Calculate percentage
        if results["total"] > 0:
            results["critical_percentage"] = round(
                (results["critical"] / results["total"]) * 100, 2
            )

        return results

    except httpx.HTTPStatusError as e:
        error_detail = "GitHub API error"
        if e.response.status_code == 403:
            error_detail = "API rate limit exceeded" if "rate limit" in str(e.response.content) else "Forbidden"
        elif e.response.status_code == 401:
            error_detail = "Invalid GitHub token"
        
        raise HTTPException(
            status_code=e.response.status_code,
            detail=f"{error_detail}: {e.response.text}"
        )
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Error analyzing GitHub commits: {str(e)}"
        )
@router.post("/analyze-text")
async def analyze_commit_text(message: str):
    """
    Ph√¢n t√≠ch m·ªôt commit message d·∫°ng text
    
    Args:
        message: N·ªôi dung commit message
    
    Returns:
        {"is_critical": 0|1, "message": string}
    """
    try:
        is_critical = predict_commit(message)
        return {
            "is_critical": is_critical,
            "message": "Ph√¢n t√≠ch th√†nh c√¥ng",
            "input_sample": message[:100] + "..." if len(message) > 100 else message
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"L·ªói ph√¢n t√≠ch: {str(e)}")

@router.post("/analyze-json")
async def analyze_commits_json(commits: List[dict]):
    """
    Ph√¢n t√≠ch nhi·ªÅu commit t·ª´ JSON
    
    Args:
        commits: List[{"id": string, "message": string}]
    
    Returns:
        {"total": int, "critical": int, "details": List[dict]}
    """
    try:
        results = {
            "total": len(commits),
            "critical": 0,
            "details": []
        }
        
        for commit in commits:
            if not isinstance(commit, dict) or 'message' not in commit:
                continue
                
            is_critical = predict_commit(commit['message'])
            if is_critical:
                results["critical"] += 1
                
            results["details"].append({
                "id": commit.get("id", ""),
                "is_critical": is_critical,
                "message_preview": commit['message'][:100] + "..." if len(commit['message']) > 100 else commit['message']
            })
            
        return JSONResponse(content=results)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"L·ªói ph√¢n t√≠ch h√†ng lo·∫°t: {str(e)}")

@router.post("/analyze-csv", response_model=dict)
async def analyze_commits_csv(file: UploadFile = File(...)):
    """
    Ph√¢n t√≠ch commit t·ª´ file CSV
    
    Args:
        file: File CSV c√≥ c·ªôt 'message' ho·∫∑c 'commit_message'
    
    Returns:
        {"filename": string, "total": int, "critical": int}
    """
    try:
        # L∆∞u file t·∫°m
        with tempfile.NamedTemporaryFile(delete=False) as tmp:
            tmp.write(await file.read())
            tmp_path = Path(tmp.name)
        
        # ƒê·ªçc file CSV
        df = pd.read_csv(tmp_path)
        tmp_path.unlink()  # X√≥a file t·∫°m
        
        # Ki·ªÉm tra c·ªôt message
        message_col = 'message' if 'message' in df.columns else 'commit_message'
        if message_col not in df.columns:
            raise HTTPException(status_code=400, detail="File thi·∫øu c·ªôt 'message' ho·∫∑c 'commit_message'")
        
        # Ph√¢n t√≠ch
        results = {
            "filename": file.filename,
            "total": len(df),
            "critical": 0,
            "sample_results": []
        }
        
        df['is_critical'] = df[message_col].apply(predict_commit)
        results["critical"] = int(df['is_critical'].sum())
        
        # L·∫•y 5 k·∫øt qu·∫£ m·∫´u
        sample = df.head(5).to_dict('records')
        results["sample_results"] = [{
            "message": row[message_col][:100] + "..." if len(row[message_col]) > 100 else row[message_col],
            "is_critical": bool(row['is_critical'])
        } for row in sample]
        
        return results
        
    except Exception as e:
        if tmp_path.exists():
            tmp_path.unlink()
        raise HTTPException(status_code=500, detail=f"L·ªói x·ª≠ l√Ω file: {str(e)}")
```

### backend\api\routes\github.py
```py
# backend/api/routes/github.py
from fastapi import APIRouter, Request, HTTPException
import httpx
from services.repo_service import get_repo_data
from services.commit_service import save_commit
from services.repo_service import get_repo_id_by_owner_and_name
from services.user_service import get_user_id_by_github_username
from services.branch_service import save_branch
from sqlalchemy.future import select
from fastapi import APIRouter, Depends
from services.repo_service import save_repository
from datetime import datetime
from sqlalchemy import select
from db.models.commits import commits
from db.models.repositories import repositories  # ƒë·ªÉ l·∫•y access token
from schemas.commit import CommitCreate  # schema
from services.github_service import fetch_commits  # h√†m g·ªçi GitHub API
from sqlalchemy.ext.asyncio import AsyncSession
from schemas.commit import CommitOut
from db.database import database

from services.branch_service import save_branches
from services.issue_service import save_issues
github_router = APIRouter()

# Endpoint l·∫•y th√¥ng tin repository c·ª• th·ªÉ
@github_router.get("/github/{owner}/{repo}")
async def fetch_repo(owner: str, repo: str):
    return await get_repo_data(owner, repo)

@github_router.get("/github/repos")
async def get_user_repos(request: Request):
    # L·∫•y token t·ª´ header Authorization
    token = request.headers.get("Authorization")
    
    # Ki·ªÉm tra token h·ª£p l·ªá (ph·∫£i b·∫Øt ƒë·∫ßu b·∫±ng "token ")
    if not token or not token.startswith("token "):
        raise HTTPException(status_code=401, detail="Missing or invalid token")
    
    # G·ªçi GitHub API ƒë·ªÉ l·∫•y danh s√°ch repo
    async with httpx.AsyncClient() as client:
        resp = await client.get(
            "https://api.github.com/user/repos",
            headers={"Authorization": token}
        )
        # N·∫øu l·ªói th√¨ raise exception
        if resp.status_code != 200:
            raise HTTPException(status_code=resp.status_code, detail=resp.text)
    
    # Tr·∫£ v·ªÅ k·∫øt qu·∫£ d·∫°ng JSON
    return resp.json()

# Endpoint l·∫•y danh s√°ch commit c·ªßa m·ªôt repository
@github_router.get("/github/{owner}/{repo}/commits")
async def get_commits(owner: str, repo: str, request: Request, branch: str = "main"):
    # L·∫•y token t·ª´ header
    token = request.headers.get("Authorization")
    if not token or not token.startswith("token "):
        raise HTTPException(status_code=401, detail="Missing or invalid token")

    # G·ªçi GitHub API ƒë·ªÉ l·∫•y commit
    async with httpx.AsyncClient() as client:
        url = f"https://api.github.com/repos/{owner}/{repo}/commits?sha={branch}"
        headers = {"Authorization": token}

        resp = await client.get(url, headers=headers)
        # X·ª≠ l√Ω tr∆∞·ªùng h·ª£p repository tr·ªëng (409)
        if resp.status_code == 409:
            return []
        # X·ª≠ l√Ω l·ªói kh√°c
        if resp.status_code != 200:
            raise HTTPException(status_code=resp.status_code, detail=resp.text)

        return resp.json()

def get_db():
    return database
# L·∫•y danh s√°ch commit t·ª´ database
@github_router.get("/github/{owner}/{repo}/commits/db")
async def get_commits_from_db(owner: str, repo: str, db: AsyncSession = Depends(get_db)):
    repo_id = await get_repo_id_by_owner_and_name(owner, repo)
    if not repo_id:
        raise HTTPException(status_code=404, detail="Repository not found")

    query = select(commits).where(commits.c.repo_id == repo_id)
    result = await db.fetch_all(query)
    return result

@github_router.get("/github/{owner}/{repo}/branches")
async def get_branches(owner: str, repo: str, request: Request):
    # L·∫•y token t·ª´ header
    token = request.headers.get("Authorization")
    if not token or not token.startswith("token "):
        raise HTTPException(status_code=401, detail="Missing or invalid token")

    # G·ªçi GitHub API l·∫•y danh s√°ch branch
    async with httpx.AsyncClient() as client:
        url = f"https://api.github.com/repos/{owner}/{repo}/branches"
        headers = {"Authorization": token}

        resp = await client.get(url, headers=headers)
        if resp.status_code != 200:
            raise HTTPException(status_code=resp.status_code, detail=resp.text)

        return resp.json()

# Endpoint l∆∞u commit v√†o database
@github_router.post("/github/{owner}/{repo}/save-commits")
async def save_repo_commits(owner: str, repo: str, request: Request, branch: str = None):
    token = request.headers.get("Authorization")
    if not token or not token.startswith("token "):
        raise HTTPException(status_code=401, detail="Missing or invalid token")

    # N·∫øu kh√¥ng truy·ªÅn branch, l·∫•y branch m·∫∑c ƒë·ªãnh t·ª´ GitHub
    if not branch:
        async with httpx.AsyncClient() as client:
            repo_url = f"https://api.github.com/repos/{owner}/{repo}"
            headers = {"Authorization": token}
            repo_resp = await client.get(repo_url, headers=headers)
            if repo_resp.status_code != 200:
                raise HTTPException(status_code=repo_resp.status_code, detail=repo_resp.text)
            repo_data = repo_resp.json()
            branch = repo_data.get("default_branch", "main")

    # L·∫•y danh s√°ch commit t·ª´ GitHub API
    async with httpx.AsyncClient() as client:
        url = f"https://api.github.com/repos/{owner}/{repo}/commits?sha={branch}"
        headers = {"Authorization": token}
        resp = await client.get(url, headers=headers)
        if resp.status_code != 200:
            raise HTTPException(status_code=resp.status_code, detail=resp.text)

        commit_list = resp.json()

    # L·∫•y repo_id t·ª´ c∆° s·ªü d·ªØ li·ªáu
    repo_id = await get_repo_id_by_owner_and_name(owner, repo)
    if not repo_id:
        raise HTTPException(status_code=404, detail="Repository not found")

    # L∆∞u t·ª´ng commit v√†o c∆° s·ªü d·ªØ li·ªáu
    async with httpx.AsyncClient() as client:
        for commit in commit_list:
            # L·∫•y th√¥ng tin chi ti·∫øt c·ªßa commit
            commit_url = f"https://api.github.com/repos/{owner}/{repo}/commits/{commit['sha']}"
            commit_resp = await client.get(commit_url, headers={"Authorization": token})
            if commit_resp.status_code != 200:
                continue  # B·ªè qua commit n·∫øu kh√¥ng l·∫•y ƒë∆∞·ª£c th√¥ng tin chi ti·∫øt

            commit_details = commit_resp.json()
            stats = commit_details.get("stats", {})
            commit_data = {
                "sha": commit["sha"],
                "message": commit["commit"]["message"],
                "author_name": commit["commit"]["author"]["name"],
                "author_email": commit["commit"]["author"]["email"],
                "date": datetime.strptime(commit["commit"]["author"]["date"], "%Y-%m-%dT%H:%M:%SZ"),
                "insertions": stats.get("additions", 0),
                "deletions": stats.get("deletions", 0),
                "files_changed": stats.get("total", 0),
                "repo_id": repo_id,
            }
            await save_commit(commit_data)

    return {"message": "Commits saved successfully!"}
#l∆∞u branchbranch v√†o database
@github_router.post("/github/{owner}/{repo}/save-branches")
async def save_branches(owner: str, repo: str, request: Request):
    token = request.headers.get("Authorization")
    if not token or not token.startswith("token "):
        raise HTTPException(status_code=401, detail="Missing or invalid token")

    # L·∫•y danh s√°ch branch t·ª´ GitHub API
    async with httpx.AsyncClient() as client:
        url = f"https://api.github.com/repos/{owner}/{repo}/branches"
        headers = {"Authorization": token}
        resp = await client.get(url, headers=headers)
        if resp.status_code != 200:
            raise HTTPException(status_code=resp.status_code, detail=resp.text)

        branches = resp.json()

    # L∆∞u branch v√†o database
    repo_id = await get_repo_id_by_owner_and_name(owner, repo)
    if not repo_id:
        raise HTTPException(status_code=404, detail="Repository not found")

    for branch in branches:
        branch_data = {
            "name": branch["name"],
            "repo_id": repo_id,
        }
        await save_branch(branch_data)

    return {"message": "Branches saved successfully!"}
# l∆∞u issues v√†o database
@github_router.post("/github/{owner}/{repo}/save-issues")
async def save_issues(owner: str, repo: str, request: Request):
    token = request.headers.get("Authorization")
    if not token or not token.startswith("token "):
        raise HTTPException(status_code=401, detail="Missing or invalid token")

    # L·∫•y danh s√°ch issue t·ª´ GitHub API
    async with httpx.AsyncClient() as client:
        url = f"https://api.github.com/repos/{owner}/{repo}/issues"
        headers = {"Authorization": token}
        resp = await client.get(url, headers=headers)
        if resp.status_code != 200:
            raise HTTPException(status_code=resp.status_code, detail=resp.text)

        issues = resp.json()

    
    # L∆∞u issue v√†o database
    repo_id = await get_repo_id_by_owner_and_name(owner, repo)
    if not repo_id:
        raise HTTPException(status_code=404, detail="Repository not found")

    for issue in issues:
        issue_data = {
            "title": issue["title"],
            "body": issue["body"],
            "state": issue["state"],
            "created_at": issue["created_at"],
            "updated_at": issue["updated_at"],
            "repo_id": repo_id,
        }
        await save_issue(issue_data)

    return {"message": "Issues saved successfully!"}
#save repo v√†o database
async def save_repo(owner: str, repo: str, request: Request):
    token = request.headers.get("Authorization")
    if not token or not token.startswith("token "):
        raise HTTPException(status_code=401, detail="Missing or invalid token")

    async with httpx.AsyncClient() as client:
        url = f"https://api.github.com/repos/{owner}/{repo}"
        headers = {"Authorization": token}
        resp = await client.get(url, headers=headers)
        if resp.status_code != 200:
            raise HTTPException(status_code=resp.status_code, detail=resp.text)

        repo_data = resp.json()

    repo_entry = {
        "github_id": repo_data["id"],
        "name": repo_data["name"],
        "owner": repo_data["owner"]["login"],
        "description": repo_data["description"],
        "stars": repo_data["stargazers_count"],
        "forks": repo_data["forks_count"],
        "language": repo_data["language"],
        "open_issues": repo_data["open_issues_count"],
        "url": repo_data["html_url"],
    }

    try:
        await save_repository(repo_entry)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error saving repository: {str(e)}")

def get_db():
    return database

# Endpoint l·∫•y t·∫•t c·∫£ commit t·ª´ database
@github_router.get("/commits")
async def get_commits(db = Depends(get_db)):
    query = commits.select()  # L·∫•y t·∫•t c·∫£ commit
    result = await db.fetch_all(query)
    return result

# Endpoint ƒë·ªìng b·ªô commit t·ª´ GitHub v·ªÅ database
@github_router.get("/sync-commits")
async def sync_commits(
    repo_id: int,
    branch: str = "main",
    since: str = None,
    until: str = None,
    db: AsyncSession = Depends(get_db)
):
    # 1. L·∫•y th√¥ng tin repository t·ª´ database
    repo = await db.scalar(select(repositories).where(repositories.c.id == repo_id))
    if not repo:
        raise HTTPException(status_code=404, detail="Repository kh√¥ng t·ªìn t·∫°i")

    # 2. G·ªçi GitHub API l·∫•y commit v·ªõi c√°c tham s·ªë l·ªçc
    commits_data = await fetch_commits(
        token=repo.token,  # Access token
        owner=repo.owner,  # Ch·ªß repository
        name=repo.name,  # T√™n repository
        branch=branch,  # Branch c·∫ßn l·∫•y
        since=since,  # L·ªçc t·ª´ th·ªùi gian
        until=until  # L·ªçc ƒë·∫øn th·ªùi gian
    )

    # 3. L∆∞u commit m·ªõi v√†o database
    new_commits = []
    for item in commits_data:
        sha = item["sha"]
        # Ki·ªÉm tra commit ƒë√£ t·ªìn t·∫°i ch∆∞a
        existing = await db.scalar(select(commits).where(commits.c.sha == sha))
        if existing:
            continue  # B·ªè qua n·∫øu ƒë√£ t·ªìn t·∫°i

        # T·∫°o commit m·ªõi
        new_commit = CommitCreate(
            sha=sha,
            message=item["commit"]["message"],
            author=item["commit"]["author"]["name"],
            date=item["commit"]["author"]["date"],
            repository_id=repo.id
        )
        commit_obj = commits.insert().values(**new_commit.dict())
        await db.execute(commit_obj)
        new_commits.append(new_commit)

    await db.commit()

    return {
        "message": f"ƒê·ªìng b·ªô th√†nh c√¥ng {len(new_commits)} commit.",
        "data": [c.sha for c in new_commits]
    }
# ƒë·ªìng b·ªô to√†n b·ªô d·ªØ li·ªáu
@github_router.post("/github/{owner}/{repo}/sync-all")
async def sync_all(owner: str, repo: str, request: Request):
    token = request.headers.get("Authorization")
    if not token or not token.startswith("token "):
        raise HTTPException(status_code=401, detail="Missing or invalid token")

    # ƒê·ªìng b·ªô repository
    await save_repo(owner, repo, request)

    # ƒê·ªìng b·ªô branches
    await save_branches(owner, repo, request)

    # ƒê·ªìng b·ªô commits
    await save_repo_commits(owner, repo, request)

    # ƒê·ªìng b·ªô issues
    await save_issues(owner, repo, request)

    return {"message": "ƒê·ªìng b·ªô to√†n b·ªô d·ªØ li·ªáu th√†nh c√¥ng!"}
```

### backend\api\routes\gitlab.py
```py

```

### backend\api\routes\repo.py
```py

```

### backend\api\routes\users.py
```py

```

### backend\api\routes\__init__.py
```py

```

### backend\core\config.py
```py
# backend/core/config.py
# File c·∫•u h√¨nh ch√≠nh cho ·ª©ng d·ª•ng FastAPI

# Import c√°c th∆∞ vi·ªán c·∫ßn thi·∫øt
import os  # L√†m vi·ªác v·ªõi bi·∫øn m√¥i tr∆∞·ªùng
from fastapi.middleware.cors import CORSMiddleware  # Middleware CORS
from starlette.middleware.sessions import SessionMiddleware  # Middleware qu·∫£n l√Ω session
from fastapi import FastAPI  # Framework ch√≠nh
from api.routes.github import github_router  # Router cho GitHub API
from api.routes.auth import auth_router  # Router cho x√°c th·ª±c
from dotenv import load_dotenv  # ƒê·ªçc file .env

# N·∫°p bi·∫øn m√¥i tr∆∞·ªùng t·ª´ file .env
load_dotenv()

# H√†m c·∫•u h√¨nh c√°c middleware cho ·ª©ng d·ª•ng
def setup_middlewares(app: FastAPI):
    """
    Thi·∫øt l·∫≠p c√°c middleware c·∫ßn thi·∫øt cho ·ª©ng d·ª•ng
    
    Args:
        app (FastAPI): Instance c·ªßa FastAPI app
    """
    
    # Th√™m middleware CORS (Cross-Origin Resource Sharing)
    app.add_middleware(
        CORSMiddleware,
        # Danh s√°ch domain ƒë∆∞·ª£c ph√©p truy c·∫≠p
        allow_origins=[
            "http://localhost:5173",  # Frontend dev (Vite th∆∞·ªùng ch·∫°y ·ªü port 5173)
            "http://localhost:3000"   # Frontend dev (React c√≥ th·ªÉ ch·∫°y ·ªü port 3000)
        ],
        allow_credentials=True,  # Cho ph√©p g·ª≠i credential (cookies, auth headers)
        allow_methods=["*"],  # Cho ph√©p t·∫•t c·∫£ HTTP methods
        allow_headers=["*"],  # Cho ph√©p t·∫•t c·∫£ headers (bao g·ªìm Authorization)
    )

    # Th√™m middleware qu·∫£n l√Ω session
    app.add_middleware(
        SessionMiddleware,
        secret_key=os.getenv('SECRET_KEY')  # Kh√≥a b√≠ m·∫≠t t·ª´ bi·∫øn m√¥i tr∆∞·ªùng
    )


# H√†m c·∫•u h√¨nh c√°c router cho ·ª©ng d·ª•ng
def setup_routers(app: FastAPI):
    """
    ƒêƒÉng k√Ω c√°c router ch√≠nh c·ªßa ·ª©ng d·ª•ng
    
    Args:
        app (FastAPI): Instance c·ªßa FastAPI app
    """
    
    # ƒêƒÉng k√Ω auth router v·ªõi prefix /auth
    app.include_router(auth_router, prefix="/auth")
    
    # ƒêƒÉng k√Ω github router v·ªõi prefix /api
    app.include_router(github_router, prefix="/api")  # G·ªôp chung kh√¥ng b·ªã ƒë√® l·∫´n nhau
```

### backend\core\lifespan.py
```py
from fastapi import FastAPI
from contextlib import asynccontextmanager
from db.database import database
import logging

logger = logging.getLogger(__name__)

@asynccontextmanager
async def lifespan(app: FastAPI):
    try:
        await database.connect()
        logger.info("‚úÖ ƒê√£ k·∫øt n·ªëi t·ªõi database th√†nh c√¥ng.")
        yield  # Ch·ªâ yield n·∫øu connect th√†nh c√¥ng
    except Exception as e:
        logger.error(f"‚ùå K·∫øt n·ªëi database th·∫•t b·∫°i: {e}")
        raise e  # D·ª´ng app n·∫øu kh√¥ng k·∫øt n·ªëi ƒë∆∞·ª£c DB
    finally:
        try:
            await database.disconnect()
            logger.info("üõë ƒê√£ ng·∫Øt k·∫øt n·ªëi database.")
        except Exception as e:
            logger.error(f"‚ùå L·ªói khi ng·∫Øt k·∫øt n·ªëi database: {e}")

```

### backend\core\logger.py
```py
# core/logger.py

import logging

def setup_logger():
    logging.basicConfig(
        level=logging.INFO,  # Hi·ªán log t·ª´ c·∫•p INFO tr·ªü l√™n
        format="%(asctime)s - %(levelname)s - %(message)s",
    )

```

### backend\core\oauth.py
```py
# backend/core/oauth.py
# File c·∫•u h√¨nh OAuth cho ·ª©ng d·ª•ng, ch·ªß y·∫øu d√πng cho GitHub OAuth

# Import c√°c th∆∞ vi·ªán c·∫ßn thi·∫øt
import os  # ƒê·ªÉ l√†m vi·ªác v·ªõi bi·∫øn m√¥i tr∆∞·ªùng
from dotenv import load_dotenv  # ƒê·ªÉ ƒë·ªçc file .env
from authlib.integrations.starlette_client import OAuth  # Th∆∞ vi·ªán OAuth cho Starlette/FastAPI

# Load c√°c bi·∫øn m√¥i tr∆∞·ªùng t·ª´ file .env
load_dotenv()

# Kh·ªüi t·∫°o instance OAuth
oauth = OAuth()

# ƒêƒÉng k√Ω provider GitHub cho OAuth
oauth.register(
    name='github',  # T√™n provider
    
    # Client ID t·ª´ ·ª©ng d·ª•ng GitHub OAuth App
    client_id=os.getenv('GITHUB_CLIENT_ID'),
    
    # Client Secret t·ª´ ·ª©ng d·ª•ng GitHub OAuth App
    client_secret=os.getenv('GITHUB_CLIENT_SECRET'),
    
    # URL ƒë·ªÉ l·∫•y access token
    access_token_url='https://github.com/login/oauth/access_token',
    
    # C√°c params th√™m khi l·∫•y access token (None n·∫øu kh√¥ng c√≥)
    access_token_params=None,
    
    # URL ƒë·ªÉ x√°c th·ª±c
    authorize_url='https://github.com/login/oauth/authorize',
    
    # C√°c params th√™m khi x√°c th·ª±c (None n·∫øu kh√¥ng c√≥)
    authorize_params=None,
    
    # Base URL cho API GitHub
    api_base_url='https://api.github.com/',
    
    # C√°c tham s·ªë b·ªï sung cho client
    client_kwargs={
        'scope': 'read:user user:email repo'  # C√°c quy·ªÅn y√™u c·∫ßu
        # read:user - ƒê·ªçc th√¥ng tin user
        # user:email - ƒê·ªçc email user
        # repo - Truy c·∫≠p repository
    }
)
```

### backend\core\security.py
```py

```

### backend\migrations\env.py
```py
import os
from dotenv import load_dotenv
from sqlalchemy import engine_from_config, pool
from alembic import context
from db.metadata import metadata  # Import metadata t·ª´ metadata.py

# N·∫°p bi·∫øn m√¥i tr∆∞·ªùng t·ª´ file .env
load_dotenv()

# L·∫•y DATABASE_URL t·ª´ bi·∫øn m√¥i tr∆∞·ªùng
config = context.config
database_url = os.getenv("DATABASE_URL").replace("asyncpg", "psycopg2")
config.set_main_option("sqlalchemy.url", database_url)

# Interpret the config file for Python logging.
# This line sets up loggers basically.
if config.config_file_name is not None:
    from logging.config import fileConfig
    fileConfig(config.config_file_name)

# add your model's MetaData object here
# for 'autogenerate' support
# from myapp import mymodel
# target_metadata = mymodel.Base.metadata
target_metadata = metadata

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online() -> None:
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """
    connectable = engine_from_config(
        config.get_section(config.config_ini_section, {}),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    with connectable.connect() as connection:
        context.configure(
            connection=connection, target_metadata=target_metadata
        )

        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()

```

### backend\models\commit_model.py
```py
# KLTN04\backend\models\commit_model.py
import pandas as pd
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.ensemble import RandomForestClassifier
import joblib

class CommitClassifier:
    def __init__(self):
        self.vectorizer = TfidfVectorizer(max_features=1000)
        self.model = RandomForestClassifier()
        self.labels = ['normal', 'critical']  # 0: normal, 1: critical/bugfix

    def train(self, df: pd.DataFrame):
        """Hu·∫•n luy·ªán model t·ª´ dataframe"""
        X = self.vectorizer.fit_transform(df['message'])
        y = df['is_critical']  # C·ªôt nh√£n (0/1)
        self.model.fit(X, y)
        
    def predict(self, new_messages: list):
        """D·ª± ƒëo√°n commit quan tr·ªçng c·∫ßn review"""
        X_new = self.vectorizer.transform(new_messages)
        return self.model.predict(X_new)
    
    def save(self, path='models/commit_classifier.joblib'):
        """L∆∞u model"""
        joblib.dump({
            'vectorizer': self.vectorizer,
            'model': self.model
        }, path)
    
    @classmethod
    def load(cls, path='models/commit_classifier.joblib'):
        """Load model ƒë√£ l∆∞u"""
        data = joblib.load(path)
        classifier = cls()
        classifier.vectorizer = data['vectorizer']
        classifier.model = data['model']
        return classifier
```

### backend\models\task_model.py
```py
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity

class TaskAssigner:
    def __init__(self):
        self.skill_matrix = None
    
    def build_skill_matrix(self, developers: list, tasks: list):
        """T·∫°o ma tr·∫≠n k·ªπ nƒÉng developer-task"""
        # Vector h√≥a k·ªπ nƒÉng (v√≠ d·ª•: [1,0,1] = bi·∫øt Python, kh√¥ng bi·∫øt SQL, bi·∫øt Docker)
        dev_vectors = [d['skill_vector'] for d in developers]
        task_vectors = [t['required_skills'] for t in tasks]
        
        self.skill_matrix = cosine_similarity(task_vectors, dev_vectors)
        return self.skill_matrix
    
    def assign_tasks(self, developers: list, tasks: list):
        """Ph√¢n c√¥ng c√¥ng vi·ªác t·ªëi ∆∞u"""
        if self.skill_matrix is None:
            self.build_skill_matrix(developers, tasks)
            
        assignments = []
        for task_idx, task in enumerate(tasks):
            best_dev_idx = np.argmax(self.skill_matrix[task_idx])
            assignments.append({
                'task_id': task['id'],
                'dev_id': developers[best_dev_idx]['id'],
                'fit_score': float(self.skill_matrix[task_idx][best_dev_idx])
            })
        return assignments
```

### backend\schemas\commit.py
```py
from pydantic import BaseModel
from datetime import datetime


class CommitCreate(BaseModel):
    commit_id: str
    message: str
    author_name: str
    author_email: str
    committed_date: datetime
    repository_id: int


class CommitOut(CommitCreate):
    id: int

    class Config:
        from_attributes = True  # D√†nh cho Pydantic V2 thay cho orm_mode

```

### backend\scripts\commit_analysis_system.py
```py
# File: backend/scripts/commit_analysis_system.py
import pandas as pd
import numpy as np
from pathlib import Path
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import classification_report
import dask.dataframe as dd
import joblib
from dask.distributed import Client
import warnings
warnings.filterwarnings('ignore')

class CommitAnalysisSystem:
    def __init__(self):
        """Kh·ªüi t·∫°o h·ªá th·ªëng v·ªõi c·∫•u h√¨nh t·ªëi ∆∞u"""
        self.vectorizer = TfidfVectorizer(
            max_features=800,
            stop_words='english',
            ngram_range=(1, 1)
        )
        self.model = RandomForestClassifier(
            n_estimators=30,
            max_depth=8,
            n_jobs=1,
            class_weight='balanced'
        )
        self.client = None

    def init_dask_client(self):
        """Kh·ªüi t·∫°o Dask client"""
        self.client = Client(n_workers=2, threads_per_worker=1, memory_limit='2GB')

    @staticmethod
    def lightweight_heuristic(msg):
        """H√†m heuristic tƒ©nh ƒë·ªÉ x·ª≠ l√Ω song song"""
        if not isinstance(msg, str) or not msg.strip():
            return 0
        msg = msg.lower()[:150]
        return int(any(kw in msg for kw in ['fix', 'bug', 'error', 'fail']))

    def process_large_file(self, input_path, output_dir):
        """X·ª≠ l√Ω file l·ªõn v·ªõi Dask """
        try:
            if self.client:
                self.client.close()
            self.init_dask_client()

            # ƒê·ªçc file v·ªõi Dask
            ddf = dd.read_csv(
                str(input_path),
                blocksize="20MB",
                dtype={'message': 'string'},
                usecols=['commit', 'message'],
                na_values=['', 'NA', 'N/A', 'nan']
            )
            
            # S·ª≠a l·ªói: Thay .notna() b·∫±ng .notnull() cho Dask
            ddf = ddf[ddf['message'].notnull()]
            
            # G√°n nh√£n
            ddf['is_critical'] = ddf['message'].map(
                self.lightweight_heuristic,
                meta=('is_critical', 'int8')
            )
            
           # L∆∞u k·∫øt qu·∫£ (ƒë√£ s·ª≠a ph·∫ßn compute)
            output_dir = Path(output_dir)
            output_dir.mkdir(exist_ok=True, parents=True)
            
            # S·ª≠a l·ªói: G·ªçi compute() tr·ª±c ti·∫øp tr√™n to_csv()
            ddf.to_csv(
                str(output_dir / "part_*.csv"),
                index=False
            )
            
            return True
        except Exception as e:
            print(f"üö® L·ªói x·ª≠ l√Ω file: {str(e)}")
            return False
        finally:
            if self.client:
                self.client.close()

    def clean_data(self, df):
        """L√†m s·∫°ch d·ªØ li·ªáu"""
        if 'message' not in df.columns:
            raise ValueError("Thi·∫øu c·ªôt 'message' trong d·ªØ li·ªáu")
        df['message'] = df['message'].astype('string').fillna('')
        return df[df['message'].str.strip() != '']

    def auto_label(self, df):
        """G√°n nh√£n t·ª± ƒë·ªông"""
        df = self.clean_data(df)
        df['is_critical'] = df['message'].apply(self.lightweight_heuristic)
        return df

    def train_model(self, df):
        """Hu·∫•n luy·ªán m√¥ h√¨nh"""
        X = self.vectorizer.fit_transform(df['message'])
        y = df['is_critical'].values
        self.model.fit(X, y)

    def evaluate(self, test_df):
        """ƒê√°nh gi√° m√¥ h√¨nh"""
        X_test = self.vectorizer.transform(test_df['message'])
        y_test = test_df['is_critical'].values
        print(classification_report(y_test, self.model.predict(X_test)))

    def save_model(self, path):
        """L∆∞u m√¥ h√¨nh"""
        Path(path).parent.mkdir(exist_ok=True, parents=True)
        joblib.dump({
            'model': self.model,
            'vectorizer': self.vectorizer
        }, str(path))

def main():
    print("üöÄ B·∫Øt ƒë·∫ßu ph√¢n t√≠ch commit...")
    system = CommitAnalysisSystem()
    
    input_path = Path("D:/Project/KLTN04/data/oneline.csv")
    output_dir = Path("D:/Project/KLTN04/data/processed")
    
    if system.process_large_file(input_path, output_dir):
        print("‚úÖ ƒê√£ x·ª≠ l√Ω file th√†nh c√¥ng")
        
        # N·∫°p v√† x·ª≠ l√Ω d·ªØ li·ªáu
        df = pd.concat([pd.read_csv(f) for f in output_dir.glob("part_*.csv")])
        df = system.auto_label(df)
        
        # Hu·∫•n luy·ªán v√† ƒë√°nh gi√°
        system.train_model(df)
        test_df = df.sample(frac=0.2, random_state=42)
        system.evaluate(test_df)
        
        # L∆∞u m√¥ h√¨nh
        model_path = "backend/models/commit_classifier.joblib"
        system.save_model(model_path)
        print(f"üíæ ƒê√£ l∆∞u m√¥ h√¨nh t·∫°i: {model_path}")

if __name__ == "__main__":
    main()
```

### backend\scripts\commit_analysis_system_v1.py
```py
# File: backend/scripts/commit_analysis_system.py
import pandas as pd
import numpy as np
from pathlib import Path
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import classification_report
import dask.dataframe as dd
import joblib
from dask.distributed import Client
import logging
from typing import Optional, Union
from datetime import datetime

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class CommitAnalysisSystem:
    """H·ªá th·ªëng ph√¢n t√≠ch commit t·ª± ƒë·ªông v·ªõi kh·∫£ nƒÉng x·ª≠ l√Ω d·ªØ li·ªáu l·ªõn"""
    
    VERSION = "1.0.0"
    
    def __init__(self, model_params: Optional[dict] = None, 
                 vectorizer_params: Optional[dict] = None):
        """
        Kh·ªüi t·∫°o h·ªá th·ªëng ph√¢n t√≠ch commit
        
        Args:
            model_params: Tham s·ªë cho RandomForestClassifier
            vectorizer_params: Tham s·ªë cho TfidfVectorizer
        """
        # C·∫•u h√¨nh m·∫∑c ƒë·ªãnh
        default_vectorizer_params = {
            'max_features': 1000,
            'stop_words': 'english',
            'ngram_range': (1, 2),  # Th√™m bigram
            'min_df': 5,
            'max_df': 0.8
        }
        
        default_model_params = {
            'n_estimators': 100,
            'max_depth': 15,
            'class_weight': 'balanced',
            'random_state': 42
        }
        
        self.vectorizer = TfidfVectorizer(**(vectorizer_params or default_vectorizer_params))
        self.model = RandomForestClassifier(**(model_params or default_model_params))
        self.client = None
        self._is_trained = False

    def init_dask_client(self, **kwargs):
        """Kh·ªüi t·∫°o Dask client v·ªõi c·∫•u h√¨nh t√πy ch·ªçn"""
        default_config = {
            'n_workers': 2,
            'threads_per_worker': 1,
            'memory_limit': '2GB',
            'silence_logs': logging.ERROR
        }
        config = {**default_config, **kwargs}
        
        try:
            self.client = Client(**config)
            logger.info(f"Dask client initialized with config: {config}")
            return True
        except Exception as e:
            logger.error(f"Failed to initialize Dask client: {str(e)}")
            return False

    @staticmethod
    def lightweight_heuristic(msg: str) -> int:
        """Ph√¢n lo·∫°i commit s·ª≠ d·ª•ng heuristic ƒë∆°n gi·∫£n
        
        Args:
            msg: N·ªôi dung commit message
            
        Returns:
            1 n·∫øu l√† commit quan tr·ªçng (bugfix), 0 n·∫øu kh√¥ng
        """
        if not isinstance(msg, str) or not msg.strip():
            return 0
            
        msg = msg.lower()[:200]  # Gi·ªõi h·∫°n ƒë·ªô d√†i x·ª≠ l√Ω
        keywords = {
            'fix', 'bug', 'error', 'fail', 'patch', 
            'resolve', 'crash', 'defect', 'issue'
        }
        return int(any(kw in msg for kw in keywords))

    def process_large_file(self, input_path: Union[str, Path], output_dir: Union[str, Path]) -> bool:
        """X·ª≠ l√Ω file d·ªØ li·ªáu l·ªõn b·∫±ng Dask"""
        try:
            input_path = Path(input_path)
            output_dir = Path(output_dir)

            if not input_path.exists():
                logger.error(f"Input file not found: {input_path}")
                return False

            logger.info(f"Starting processing large file: {input_path}")
            start_time = datetime.now()

            # Kh·ªüi t·∫°o Dask client
            if not self.init_dask_client():
                return False

            try:
                # ƒê·ªçc v√† x·ª≠ l√Ω d·ªØ li·ªáu
                ddf = dd.read_csv(
                    str(input_path),
                    blocksize="10MB",  # Gi·∫£m k√≠ch th∆∞·ªõc block ƒë·ªÉ an to√†n
                    dtype={'message': 'string'},
                    usecols=['commit', 'message'],
                    na_values=['', 'NA', 'N/A', 'nan']
                )

                # L·ªçc v√† g√°n nh√£n
                ddf = ddf[ddf['message'].notnull()]
                ddf['is_critical'] = ddf['message'].map(
                    self.lightweight_heuristic,
                    meta=('is_critical', 'int8')
                )

                # L∆∞u k·∫øt qu·∫£
                output_dir.mkdir(exist_ok=True, parents=True)
                output_path = str(output_dir / f"processed_{input_path.stem}.csv")

                # S·ª≠ d·ª•ng dask.dataframe.to_csv v·ªõi single_file=True
                ddf.to_csv(
                    output_path,
                    index=False,
                    single_file=True
                )

                logger.info(f"Processing completed in {datetime.now() - start_time}")
                logger.info(f"Results saved to: {output_path}")
                return True

            except Exception as e:
                logger.exception(f"Error during processing: {str(e)}")
                return False

        except Exception as e:
            logger.exception(f"System error: {str(e)}")
            return False

        finally:
            if self.client:
                self.client.close()
                self.client = None

    def clean_data(self, df: pd.DataFrame) -> pd.DataFrame:
        """L√†m s·∫°ch d·ªØ li·ªáu ƒë·∫ßu v√†o
        
        Args:
            df: DataFrame ch·ª©a d·ªØ li·ªáu commit
            
        Returns:
            DataFrame ƒë√£ ƒë∆∞·ª£c l√†m s·∫°ch
        """
        if 'message' not in df.columns:
            raise ValueError("Input data must contain 'message' column")
            
        df = df.copy()
        df['message'] = df['message'].astype('string').fillna('')
        return df[df['message'].str.strip() != '']

    def auto_label(self, df: pd.DataFrame) -> pd.DataFrame:
        """T·ª± ƒë·ªông g√°n nh√£n cho d·ªØ li·ªáu commit
        
        Args:
            df: DataFrame ch·ª©a c√°c commit message
            
        Returns:
            DataFrame ƒë√£ ƒë∆∞·ª£c g√°n nh√£n
        """
        try:
            df = self.clean_data(df)
            df['is_critical'] = df['message'].apply(self.lightweight_heuristic)
            logger.info(f"Label distribution:\n{df['is_critical'].value_counts()}")
            return df
        except Exception as e:
            logger.error(f"Auto-labeling failed: {str(e)}")
            raise

    def train_model(self, df: pd.DataFrame) -> bool:
        """Hu·∫•n luy·ªán m√¥ h√¨nh ph√¢n lo·∫°i commit
        
        Args:
            df: DataFrame ƒë√£ ƒë∆∞·ª£c g√°n nh√£n
            
        Returns:
            True n·∫øu hu·∫•n luy·ªán th√†nh c√¥ng
        """
        try:
            logger.info("Starting model training...")
            
            X = self.vectorizer.fit_transform(df['message'])
            y = df['is_critical'].values
            
            self.model.fit(X, y)
            self._is_trained = True
            
            logger.info("Model training completed successfully")
            return True
        except Exception as e:
            logger.error(f"Training failed: {str(e)}")
            return False

    def evaluate(self, test_df: pd.DataFrame) -> None:
        """ƒê√°nh gi√° hi·ªáu su·∫•t m√¥ h√¨nh
        
        Args:
            test_df: DataFrame ch·ª©a d·ªØ li·ªáu test
        """
        if not self._is_trained:
            logger.warning("Model has not been trained yet")
            return
            
        X_test = self.vectorizer.transform(test_df['message'])
        y_test = test_df['is_critical'].values
        y_pred = self.model.predict(X_test)
        
        report = classification_report(
            y_test, 
            y_pred, 
            target_names=['normal', 'critical']
        )
        logger.info(f"\nModel evaluation:\n{report}")

    def save_model(self, path: Union[str, Path]) -> bool:
        """L∆∞u m√¥ h√¨nh v√† vectorizer
        
        Args:
            path: ƒê∆∞·ªùng d·∫´n l∆∞u model
            
        Returns:
            True n·∫øu l∆∞u th√†nh c√¥ng
        """
        try:
            path = Path(path)
            path.parent.mkdir(exist_ok=True, parents=True)
            
            model_data = {
                'model': self.model,
                'vectorizer': self.vectorizer,
                'version': self.VERSION,
                'timestamp': datetime.now().isoformat()
            }
            
            joblib.dump(model_data, str(path))
            logger.info(f"Model saved to {path}")
            return True
        except Exception as e:
            logger.error(f"Failed to save model: {str(e)}")
            return False

    @classmethod
    def load_model(cls, path: Union[str, Path]):
        """T·∫£i m√¥ h√¨nh ƒë√£ l∆∞u
        
        Args:
            path: ƒê∆∞·ªùng d·∫´n ƒë·∫øn file model
            
        Returns:
            Instance c·ªßa CommitAnalysisSystem v·ªõi model ƒë√£ t·∫£i
        """
        try:
            path = Path(path)
            model_data = joblib.load(str(path))
            
            system = cls()
            system.model = model_data['model']
            system.vectorizer = model_data['vectorizer']
            system._is_trained = True
            
            logger.info(f"Loaded model (v{model_data.get('version', 'unknown')} "
                       f"created at {model_data.get('timestamp', 'unknown')}")
            return system
        except Exception as e:
            logger.error(f"Failed to load model: {str(e)}")
            raise

def main():
    """Entry point cho ·ª©ng d·ª•ng"""
    try:
        logger.info("üöÄ Starting commit analysis system")
        
        # C·∫•u h√¨nh ƒë∆∞·ªùng d·∫´n
        input_path = Path("D:/Project/KLTN04/data/oneline.csv")
        output_dir = Path("D:/Project/KLTN04/data/processed")
        model_path = Path("backend/models/commit_classifier_v1.joblib")
        
        # Kh·ªüi t·∫°o h·ªá th·ªëng
        system = CommitAnalysisSystem()
        
        # X·ª≠ l√Ω d·ªØ li·ªáu l·ªõn
        if system.process_large_file(input_path, output_dir):
            # T·ªïng h·ª£p k·∫øt qu·∫£
            df = pd.concat([
                pd.read_csv(f) 
                for f in output_dir.glob("processed_*.csv")
            ])
            
            # G√°n nh√£n v√† hu·∫•n luy·ªán
            labeled_data = system.auto_label(df)
            system.train_model(labeled_data)
            
            # ƒê√°nh gi√° tr√™n t·∫≠p test
            test_df = labeled_data.sample(frac=0.2, random_state=42)
            system.evaluate(test_df)
            
            # L∆∞u model
            if system.save_model(model_path):
                logger.info(f"‚úÖ Pipeline completed successfully. Model saved to {model_path}")
        
    except Exception as e:
        logger.exception("‚ùå Critical error in main pipeline")
    finally:
        logger.info("üèÅ System shutdown")

if __name__ == "__main__":
    main()
```

### backend\services\ai_model.py
```py

```

### backend\services\ai_service.py
```py
from models.commit_model import CommitClassifier
from models.task_model import TaskAssigner
from fastapi import APIRouter

router = APIRouter()
commit_model = CommitClassifier.load()
task_model = TaskAssigner()

@router.post("/analyze-commits")
async def analyze_commits(messages: list[str]):
    predictions = commit_model.predict(messages)
    return {"predictions": predictions.tolist()}

@router.post("/assign-tasks")
async def assign_tasks(developers: list, tasks: list):
    assignments = task_model.assign_tasks(developers, tasks)
    return {"assignments": assignments}
```

### backend\services\branch_service.py
```py
from db.models.branches import branches
from db.database import database
from fastapi import HTTPException, Request
import httpx
import logging

logger = logging.getLogger(__name__)

async def get_repo_id_by_owner_and_name(owner: str, repo: str):
    # Placeholder function for getting repository ID by owner and name
    pass

async def save_branch(branch_data):
    query = branches.insert().values(
        name=branch_data["name"],
        repo_id=branch_data["repo_id"],
    )
    await database.execute(query)

async def save_branches(owner: str, repo: str, request: Request):
    token = request.headers.get("Authorization")
    if not token or not token.startswith("token "):
        raise HTTPException(status_code=401, detail="Missing or invalid token")

    async with httpx.AsyncClient() as client:
        url = f"https://api.github.com/repos/{owner}/{repo}/branches"
        headers = {"Authorization": token}
        resp = await client.get(url, headers=headers)
        if resp.status_code != 200:
            raise HTTPException(status_code=resp.status_code, detail=resp.text)

        branches = resp.json()
        logger.info(f"Branches data: {branches}")

    repo_id = await get_repo_id_by_owner_and_name(owner, repo)
    if not repo_id:
        raise HTTPException(status_code=404, detail="Repository not found")

    for branch in branches:
        branch_data = {
            "name": branch["name"],
            "repo_id": repo_id,
        }
        await save_branch(branch_data)
```

### backend\services\commit_service.py
```py
from db.models.commits import commits
from db.database import database
from sqlalchemy import select

async def save_commit(commit_data):
    # Ki·ªÉm tra commit ƒë√£ t·ªìn t·∫°i ch∆∞a
    query = select(commits).where(commits.c.sha == commit_data["sha"])
    existing_commit = await database.fetch_one(query)

    if existing_commit:
        return  # B·ªè qua n·∫øu commit ƒë√£ t·ªìn t·∫°i

    # Ch√®n commit m·ªõi
    query = commits.insert().values(commit_data)
    await database.execute(query)
```

### backend\services\github_service.py
```py
# backend/services/github_service.py
# Service x·ª≠ l√Ω c√°c t∆∞∆°ng t√°c v·ªõi GitHub API

# Import c√°c th∆∞ vi·ªán c·∫ßn thi·∫øt
import httpx  # Th∆∞ vi·ªán HTTP client async
import os  # L√†m vi·ªác v·ªõi bi·∫øn m√¥i tr∆∞·ªùng
from dotenv import load_dotenv  # ƒê·ªçc file .env
from typing import Optional  # ƒê·ªÉ khai b√°o ki·ªÉu d·ªØ li·ªáu optional
load_dotenv()  # N·∫°p bi·∫øn m√¥i tr∆∞·ªùng t·ª´ file .env

# L·∫•y GitHub token t·ª´ bi·∫øn m√¥i tr∆∞·ªùng
GITHUB_TOKEN = os.getenv("GITHUB_TOKEN")

# Base URL cho GitHub API
BASE_URL = "https://api.github.com"

# Headers m·∫∑c ƒë·ªãnh cho c√°c request GitHub API
headers = {
    "Authorization": f"Bearer {GITHUB_TOKEN}",  # Token x√°c th·ª±c
    "Accept": "application/vnd.github+json",  # Lo·∫°i response mong mu·ªën
}

async def fetch_from_github(url: str):
    """
    H√†m t·ªïng qu√°t ƒë·ªÉ fetch d·ªØ li·ªáu t·ª´ GitHub API
    
    Args:
        url (str): Ph·∫ßn cu·ªëi c·ªßa URL (sau BASE_URL)
    
    Returns:
        dict: D·ªØ li·ªáu JSON tr·∫£ v·ªÅ t·ª´ GitHub API
    
    Raises:
        HTTPError: N·∫øu request l·ªói
    """
    async with httpx.AsyncClient() as client:
        # G·ªçi GET request t·ªõi GitHub API
        response = await client.get(f"{BASE_URL}{url}", headers=headers)
        # T·ª± ƒë·ªông raise exception n·∫øu c√≥ l·ªói HTTP
        response.raise_for_status()
        # Tr·∫£ v·ªÅ d·ªØ li·ªáu d·∫°ng JSON
        return response.json()

async def fetch_commits(
    token: str, 
    owner: str, 
    name: str, 
    branch: str, 
    since: Optional[str], 
    until: Optional[str]
):
    """
    L·∫•y danh s√°ch commit t·ª´ repository GitHub
    
    Args:
        token (str): GitHub access token
        owner (str): Ch·ªß repository
        name (str): T√™n repository
        branch (str): T√™n branch
        since (Optional[str]): L·ªçc commit t·ª´ th·ªùi gian n√†y (ISO format)
        until (Optional[str]): L·ªçc commit ƒë·∫øn th·ªùi gian n√†y (ISO format)
    
    Returns:
        list: Danh s√°ch commit
    
    Raises:
        HTTPError: N·∫øu request l·ªói
    """
    # X√¢y d·ª±ng URL API ƒë·ªÉ l·∫•y commit
    url = f"https://api.github.com/repos/{owner}/{name}/commits"
    
    # Headers cho request
    headers = {
        "Authorization": f"token {token}",  # S·ª≠ d·ª•ng token t·ª´ tham s·ªë
        "Accept": "application/vnd.github+json"  # Lo·∫°i response mong mu·ªën
    }
    
    # Parameters cho request
    params = {
        "sha": branch  # L·ªçc theo branch
    }
    
    # Th√™m tham s·ªë l·ªçc th·ªùi gian n·∫øu c√≥
    if since:
        params["since"] = since
    if until:
        params["until"] = until

    # G·ªçi API GitHub
    async with httpx.AsyncClient() as client:
        res = await client.get(url, headers=headers, params=params)
        # Ki·ªÉm tra l·ªói HTTP
        res.raise_for_status()
        # Tr·∫£ v·ªÅ d·ªØ li·ªáu d·∫°ng JSON
        return res.json()
```

### backend\services\gitlab_service.py
```py

```

### backend\services\issue_service.py
```py
from db.database import database
from db.models import issues

# L∆∞u m·ªôt issue duy nh·∫•t
async def save_issue(issue_data):
    query = issues.insert().values(
        github_id=issue_data["github_id"],
        title=issue_data["title"],
        body=issue_data["body"],
        state=issue_data["state"],
        created_at=issue_data["created_at"],
        updated_at=issue_data["updated_at"],
        repo_id=issue_data["repo_id"],
    )
    await database.execute(query)

# L∆∞u danh s√°ch nhi·ªÅu issue
async def save_issues(issue_list):
    for issue in issue_list:
        await save_issue(issue)

```

### backend\services\model_loader.py
```py
# KLTN04\backend\services\model_loader.py
import joblib
from pathlib import Path
from typing import Optional, Union
import logging
from functools import lru_cache
import numpy as np

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class ModelLoader:
    _instance = None
    
    def __init__(self):
        try:
            model_path = self._get_model_path()
            logger.info(f"Loading model from {model_path}")
            
            self.model_data = joblib.load(model_path)
            self.model = self.model_data['model']
            self.vectorizer = self.model_data['vectorizer']
            
            # Warm-up predict
            self._warm_up()
            logger.info("Model loaded successfully")
            
        except Exception as e:
            logger.exception("Failed to load model")
            raise

    @staticmethod
    def _get_model_path() -> Path:
        """Validate and return model path"""
        model_path = Path(__file__).parent.parent / "models" / "commit_classifier_v1.joblib"
        if not model_path.exists():
            raise FileNotFoundError(f"Model file not found at {model_path}")
        return model_path

    def _warm_up(self):
        """Warm-up model with sample input"""
        sample = "fix: critical security vulnerability"
        self.predict(sample)
        
    @lru_cache(maxsize=1000)
    def vectorize(self, message: str) -> np.ndarray:
        """Cache vectorized results for frequent messages"""
        return self.vectorizer.transform([message])

    def predict(self, message: str) -> int:
        """Predict if commit is critical (with input validation)"""
        if not message or not isinstance(message, str):
            raise ValueError("Input must be non-empty string")
            
        X = self.vectorize(message.strip())
        return int(self.model.predict(X)[0])

    @classmethod
    def get_instance(cls):
        if cls._instance is None:
            cls._instance = cls()
        return cls._instance

def predict_commit(message: str) -> dict:
    """Public API for commit prediction
    
    Returns:
        {
            "prediction": 0|1,
            "confidence": float,
            "error": str|None
        }
    """
    try:
        loader = ModelLoader.get_instance()
        proba = loader.model.predict_proba(loader.vectorize(message))[0]
        return {
            "prediction": loader.predict(message),
            "confidence": float(np.max(proba)),
            "error": None
        }
    except Exception as e:
        logger.error(f"Prediction failed: {str(e)}")
        return {
            "prediction": -1,
            "confidence": 0.0,
            "error": str(e)
        }
```

### backend\services\report_generator.py
```py

```

### backend\services\repo_service.py
```py
# backend/services/repo_service.py
from .github_service import fetch_from_github
from db.models.repositories import repositories
from sqlalchemy import select, update
from sqlalchemy.sql import func
from db.database import database

async def get_repo_data(owner: str, repo: str):
    url = f"/repos/{owner}/{repo}"
    data = await fetch_from_github(url)

    # Optionally: l·ªçc data b·∫°n mu·ªën tr·∫£ v·ªÅ
    return {
        "name": data.get("name"),
        "full_name": data.get("full_name"),
        "description": data.get("description"),
        "owner": data.get("owner", {}).get("login"),
        "stars": data.get("stargazers_count"),
        "forks": data.get("forks_count"),
        "watchers": data.get("watchers_count"),
        "language": data.get("language"),
        "open_issues": data.get("open_issues_count"),
        "url": data.get("html_url"),
        "created_at": data.get("created_at"),
        "updated_at": data.get("updated_at"),
    }


async def get_repo_id_by_owner_and_name(owner: str, repo_name: str):
    query = select(repositories).where(
        repositories.c.owner == owner,
        repositories.c.name == repo_name
    )
    result = await database.fetch_one(query)
    if result:
        return result.id
    return None


async def save_repository(repo_entry):
    # Ki·ªÉm tra xem repository ƒë√£ t·ªìn t·∫°i ch∆∞a
    query = select(repositories).where(repositories.c.github_id == repo_entry["github_id"])
    existing_repo = await database.fetch_one(query)

    if existing_repo:
        # N·∫øu repository ƒë√£ t·ªìn t·∫°i, c·∫≠p nh·∫≠t th√¥ng tin (n·∫øu c·∫ßn)
        update_query = (
            update(repositories)
            .where(repositories.c.github_id == repo_entry["github_id"])
            .values(
                name=repo_entry["name"],
                owner=repo_entry["owner"],
                description=repo_entry["description"],
                stars=repo_entry["stars"],
                forks=repo_entry["forks"],
                language=repo_entry["language"],
                open_issues=repo_entry["open_issues"],
                url=repo_entry["url"],
                updated_at=func.now(),
            )
        )
        await database.execute(update_query)
    else:
        # N·∫øu repository ch∆∞a t·ªìn t·∫°i, ch√®n m·ªõi
        query = repositories.insert().values(repo_entry)
        await database.execute(query)
```

### backend\services\user_service.py
```py
from db.models.users import users
from sqlalchemy import select, insert, update, func
from db.database import database

async def get_user_id_by_github_username(username: str):
    query = select(users).where(users.c.github_username == username)
    result = await database.fetch_one(query)
    if result:
        return result.id
    return None

async def save_user(user_data):
    # Ki·ªÉm tra xem ng∆∞·ªùi d√πng ƒë√£ t·ªìn t·∫°i ch∆∞a
    query = select(users).where(users.c.github_id == user_data["github_id"])
    existing_user = await database.fetch_one(query)

    if existing_user:
        # N·∫øu ƒë√£ t·ªìn t·∫°i, c·∫≠p nh·∫≠t th√¥ng tin
        query = (
            update(users)
            .where(users.c.github_id == user_data["github_id"])
            .values(
                github_username=user_data["github_username"],
                email=user_data["email"],
                avatar_url=user_data["avatar_url"],
                updated_at=func.now()  # C·∫≠p nh·∫≠t th·ªùi gian
            )
        )
    else:
        # N·∫øu ch∆∞a t·ªìn t·∫°i, th√™m m·ªõi
        query = insert(users).values(
            github_id=user_data["github_id"],
            github_username=user_data["github_username"],
            email=user_data["email"],
            avatar_url=user_data["avatar_url"]
        )

    # Th·ª±c thi truy v·∫•n
    await database.execute(query)

```

### backend\services\__init__.py
```py

```

### backend\utils\formatter.py
```py

```

### backend\utils\scheduler.py
```py

```

### backend\utils\__init__.py
```py

```

### frontend\eslint.config.js
```js
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'

export default [
  { ignores: ['dist'] },
  {
    files: ['**/*.{js,jsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...js.configs.recommended.rules,
      ...reactHooks.configs.recommended.rules,
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
]

```

### frontend\vite.config.js
```js
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
})

```

### frontend\src\App.jsx
```jsx
import { BrowserRouter as Router, Routes, Route, Navigate } from "react-router-dom";
import Login from "./pages/Login";
import AuthSuccess from "./pages/AuthSuccess";
import Dashboard from "./pages/Dashboard"; 
import RepoDetails from "./pages/RepoDetails";
import CommitTable from './components/commits/CommitTable';

function App() {
  return (
    <Router>
      <Routes>
        {/* ‚úÖ Trang m·∫∑c ƒë·ªãnh l√† Login */}
        <Route path="/" element={<Navigate to="/login" />} />

        {/* C√°c route ch√≠nh */}
        <Route path="/login" element={<Login />} />
        <Route path="/auth-success" element={<AuthSuccess />} />
        <Route path="/dashboard" element={<Dashboard />} />
        <Route path="/repo/:owner/:repo" element={<RepoDetails />} />
        <Route path="/commits" element={<CommitTable />} />

      </Routes>
    </Router>
  );
}

export default App;

```

### frontend\src\config.js
```js

```

### frontend\src\main.jsx
```jsx
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css';
import App from './App.jsx'

createRoot(document.getElementById('root')).render(
  <StrictMode>
    <App />
  </StrictMode>,
)

```

### frontend\src\api\github.js
```js

```

### frontend\src\components\Branchs\BranchSelector.jsx
```jsx
import { useEffect, useState } from "react";
import { Select, Spin, message, Tag, Typography, Divider } from "antd";
import { GithubOutlined, BranchesOutlined } from '@ant-design/icons';
import axios from "axios";
import styled from "styled-components";

const { Option } = Select;
const { Text } = Typography;

const SelectContainer = styled.div`
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 8px 12px;
  background: #f8f9fa;
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
`;

const StyledSelect = styled(Select)`
  min-width: 240px;
  
  .ant-select-selector {
    border-radius: 6px !important;
    border: 1px solid #d9d9d9 !important;
    transition: all 0.3s !important;
    
    &:hover {
      border-color: #1890ff !important;
    }
  }
  
  .ant-select-selection-item {
    font-weight: 500;
  }
`;

const BranchTag = styled(Tag)`
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 4px 8px;
  border-radius: 6px;
  background: #f0f5ff;
  color: #1890ff;
  border: 1px solid #d6e4ff;
`;

const BranchSelector = ({ owner, repo, onBranchChange }) => {
  const [branches, setBranches] = useState([]);
  const [loading, setLoading] = useState(true);
  const [selectedBranch, setSelectedBranch] = useState(null);

  useEffect(() => {
    const token = localStorage.getItem("access_token");
    if (!token) return;

    const fetchBranches = async () => {
      try {
        const response = await axios.get(
          `http://localhost:8000/api/github/${owner}/${repo}/branches`,
          {
            headers: {
              Authorization: `token ${token}`,
            },
          }
        );
        setBranches(response.data);
        if (response.data.length > 0) {
          setSelectedBranch(response.data[0].name);
          onBranchChange(response.data[0].name);
        }
      } catch (err) {
        console.error(err);
        message.error("Kh√¥ng l·∫•y ƒë∆∞·ª£c danh s√°ch branch");
      } finally {
        setLoading(false);
      }
    };

    fetchBranches();
  }, [owner, repo]);

  const handleChange = (value) => {
    setSelectedBranch(value);
    onBranchChange(value);
  };

  if (loading) return <Spin size="small" />;

  return (
    <div style={{ marginBottom: 16 }}>
      {/* <Divider orientation="left" style={{ fontSize: 32, color: '#666' }}>
        Ch·ªçn branch
      </Divider> */}
      
      <SelectContainer>
        <BranchTag>
          <BranchesOutlined />
          <Text strong>Branch:</Text>
        </BranchTag>
        
        <StyledSelect
          value={selectedBranch}
          onChange={handleChange}
          suffixIcon={<GithubOutlined style={{ color: '#1890ff' }} />}
          dropdownMatchSelectWidth={false}
        >
          {branches.map((branch) => (
            <Option key={branch.name} value={branch.name}>
              <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
                <BranchesOutlined style={{ color: '#52c41a' }} />
                <Text strong>{branch.name}</Text>
              </div>
            </Option>
          ))}
        </StyledSelect>
      </SelectContainer>
    </div>
  );
};

export default BranchSelector;
```

### frontend\src\components\commits\AnalyzeGitHubCommits.jsx
```jsx
import { useState } from 'react';
import { Button, Badge, Popover, List, Typography, Divider, Spin, Tag, Alert, Tooltip } from 'antd';
import { ExclamationCircleFilled, CheckCircleFilled, InfoCircleOutlined } from '@ant-design/icons';
import axios from 'axios';

const { Text, Title } = Typography;

const AnalyzeGitHubCommits = ({ repo }) => {
  const [analysis, setAnalysis] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [popoverVisible, setPopoverVisible] = useState(false);

  const analyzeCommits = async () => {
    try {
      setLoading(true);
      setError(null);
      const token = localStorage.getItem("access_token");
      
      if (!token) {
        throw new Error('Authentication required');
      }

      const response = await axios.get(
        `http://localhost:8000/api/commits/analyze-github/${repo.owner.login}/${repo.name}`,
        {
          headers: { 
            Authorization: `Bearer ${token}`,
            Accept: "application/json"
          },
          params: { 
            per_page: 10,
            // Add cache busting to avoid stale data
            timestamp: Date.now()
          },
          timeout: 10000 // 10 second timeout
        }
      );
      
      if (!response.data) {
        throw new Error('Invalid response data');
      }

      setAnalysis(response.data);
    } catch (err) {
      let errorMessage = 'Failed to analyze commits';
      
      if (err.response) {
        if (err.response.status === 401) {
          errorMessage = 'Please login to analyze commits';
        } else if (err.response.status === 403) {
          errorMessage = 'Access to this repository is denied';
        } else if (err.response.data?.detail) {
          errorMessage = err.response.data.detail;
        }
      } else if (err.message) {
        errorMessage = err.message;
      }

      setError(errorMessage);
    } finally {
      setLoading(false);
    }
  };

  const handlePopoverOpen = (visible) => {
    setPopoverVisible(visible);
    if (visible && !analysis && !error) {
      analyzeCommits();
    }
  };

  const getStatusColor = () => {
    if (error) return 'warning';
    if (!analysis) return 'default';
    return analysis.critical > 0 ? 'error' : 'success';
  };

  const getStatusText = () => {
    if (error) return 'Error';
    if (!analysis) return 'Analyze Commits';
    return analysis.critical > 0 
      ? `${analysis.critical} Critical` 
      : 'No Issues';
  };

  const getStatusIcon = () => {
    if (error) return <InfoCircleOutlined />;
    if (!analysis) return null;
    return analysis.critical > 0 
      ? <ExclamationCircleFilled /> 
      : <CheckCircleFilled />;
  };

  const renderContent = () => {
    if (loading) {
      return <Spin size="small" tip="Analyzing commits..." />;
    }

    if (error) {
      return (
        <Alert
          message="Analysis Failed"
          description={error}
          type="error"
          showIcon
        />
      );
    }

    if (!analysis) {
      return <Text type="secondary">Click to analyze commits</Text>;
    }

    return (
      <>
        <div style={{ marginBottom: 16 }}>
          <Title level={5} style={{ marginBottom: 4 }}>
            Commit Analysis Summary
          </Title>
          <Text>
            <Tag color={analysis.critical > 0 ? 'error' : 'success'}>
              {analysis.critical > 0 ? 'Needs Review' : 'All Clear'}
            </Tag>
            {analysis.critical} of {analysis.total} commits are critical
          </Text>
        </div>

        <Divider style={{ margin: '12px 0' }} />

        <List
          size="small"
          dataSource={analysis.details.slice(0, 5)}
          renderItem={item => (
            <List.Item>
              <div style={{ width: '100%' }}>
                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                  <Tag color={item.is_critical ? 'error' : 'success'}>
                    {item.is_critical ? 'CRITICAL' : 'Normal'}
                  </Tag>
                  <Tooltip title="Commit ID">
                    <Text code style={{ fontSize: 12 }}>
                      {item.id.substring(0, 7)}
                    </Text>
                  </Tooltip>
                </div>
                <Text
                  ellipsis={{ tooltip: item.message_preview }}
                  style={{ 
                    color: item.is_critical ? '#f5222d' : 'inherit',
                    marginTop: 4,
                    display: 'block'
                  }}
                >
                  {item.message_preview}
                </Text>
              </div>
            </List.Item>
          )}
        />

        {analysis.total > 5 && (
          <Text type="secondary" style={{ display: 'block', marginTop: 8 }}>
            Showing 5 of {analysis.total} commits
          </Text>
        )}
      </>
    );
  };

  return (
    <Popover 
      content={renderContent()}
      title={
        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
          <span>Commit Analysis</span>
          {analysis && (
            <Badge 
              count={`${analysis.critical_percentage}%`} 
              style={{ 
                backgroundColor: analysis.critical > 0 ? '#f5222d' : '#52c41a'
              }} 
            />
          )}
        </div>
      }
      trigger="click"
      open={popoverVisible}
      onOpenChange={handlePopoverOpen}
      overlayStyle={{ width: 350 }}
      placement="bottomRight"
    >
      <Badge 
        count={analysis?.critical || 0} 
        color={getStatusColor()}
        offset={[-10, 10]}
      >
        <Button 
          type={error ? 'default' : analysis ? (analysis.critical ? 'danger' : 'success') : 'default'}
          icon={getStatusIcon()}
          loading={loading}
          onClick={(e) => e.stopPropagation()}
          style={{ 
            marginLeft: 'auto',
            fontWeight: 500,
            borderRadius: 20,
            padding: '0 16px',
            border: error ? '1px solid #faad14' : undefined
          }}
        >
          {getStatusText()}
        </Button>
      </Badge>
    </Popover>
  );
};

export default AnalyzeGitHubCommits;
```

### frontend\src\components\commits\CommitAnalysisBadge.jsx
```jsx
// components/CommitAnalysisBadge.jsx
import { Tag, Tooltip, Popover, List, Typography, Divider, Badge, Spin } from 'antd';
import { ExclamationCircleFilled, CheckCircleFilled } from '@ant-design/icons';
import { useState } from 'react';
import axios from 'axios';

const { Text } = Typography;

const CommitAnalysisBadge = ({ repo }) => {
  const [analysis, setAnalysis] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  const fetchCommitAnalysis = async () => {
    try {
      setLoading(true);
      setError(null);
      const token = localStorage.getItem("access_token");
      const response = await axios.get(
        `http://localhost:8000/api/github/repos/${repo.owner.login}/${repo.name}/commits`,
        {
          headers: { Authorization: `token ${token}` },
          params: { per_page: 5 } // Get last 5 commits for analysis
        }
      );
      
      // Analyze the commits
      const analysisRes = await axios.post(
        'http://localhost:8000/api/commits/analyze-json',
        {
          commits: response.data.map(commit => ({
            id: commit.sha,
            message: commit.commit.message
          }))
        },
        {
          headers: { Authorization: `token ${token}` }
        }
      );
      
      setAnalysis(analysisRes.data);
    } catch (err) {
      setError(err.response?.data?.detail || 'Failed to analyze commits');
    } finally {
      setLoading(false);
    }
  };

  const getStatusColor = () => {
    if (!analysis) return 'default';
    return analysis.critical > 0 ? 'error' : 'success';
  };

  const getStatusText = () => {
    if (!analysis) return 'Analyze Commits';
    return analysis.critical > 0 
      ? `${analysis.critical} Critical Commits` 
      : 'No Critical Commits';
  };

  const getStatusIcon = () => {
    if (!analysis) return null;
    return analysis.critical > 0 
      ? <ExclamationCircleFilled /> 
      : <CheckCircleFilled />;
  };

  const content = (
    <div style={{ maxWidth: 300 }}>
      {loading && <Spin size="small" />}
      {error && <Text type="danger">{error}</Text>}
      {analysis && (
        <>
          <Text strong>Recent Commits Analysis</Text>
          <Divider style={{ margin: '8px 0' }} />
          <List
            size="small"
            dataSource={analysis.details.slice(0, 5)}
            renderItem={item => (
              <List.Item>
                <div style={{ width: '100%' }}>
                  <div style={{ 
                    display: 'flex', 
                    justifyContent: 'space-between',
                    marginBottom: 4
                  }}>
                    <Text 
                      ellipsis 
                      style={{ 
                        maxWidth: 180,
                        color: item.is_critical ? '#f5222d' : 'inherit'
                      }}
                    >
                      {item.message_preview}
                    </Text>
                    <Tag color={item.is_critical ? 'error' : 'success'}>
                      {item.is_critical ? 'Critical' : 'Normal'}
                    </Tag>
                  </div>
                  <Text type="secondary" style={{ fontSize: 12 }}>
                    {item.id.substring(0, 7)}
                  </Text>
                </div>
              </List.Item>
            )}
          />
          <Divider style={{ margin: '8px 0' }} />
          <Text type="secondary">
            {analysis.critical} of {analysis.total} recent commits are critical
          </Text>
        </>
      )}
    </div>
  );

  return (
    <Popover 
      content={content}
      title="Commit Analysis"
      trigger="click"
      onVisibleChange={visible => visible && !analysis && fetchCommitAnalysis()}
    >
      <Badge 
        count={analysis?.critical || 0} 
        style={{ backgroundColor: getStatusColor() }}
      >
        <Tag 
          icon={getStatusIcon()}
          color={getStatusColor()}
          style={{ cursor: 'pointer' }}
        >
          {getStatusText()}
        </Tag>
      </Badge>
    </Popover>
  );
};

export default CommitAnalysisBadge;
```

### frontend\src\components\commits\CommitAnalysisModal.jsx
```jsx
// components/CommitAnalysisModal.jsx
import { Modal, List, Typography, Tag, Divider, Spin, Tabs, Progress, Alert } from 'antd';
import { 
  ExclamationCircleOutlined, 
  CheckCircleOutlined,
  BarChartOutlined,
  FileTextOutlined 
} from '@ant-design/icons';
import axios from 'axios';
import { useState, useEffect } from 'react';

const { Title, Text } = Typography;
const { TabPane } = Tabs;

const CommitAnalysisModal = ({ repo, visible, onCancel }) => {
  const [analysis, setAnalysis] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  const fetchFullAnalysis = async () => {
    try {
      setLoading(true);
      setError(null);
      const token = localStorage.getItem("access_token");
      const response = await axios.get(
        `http://localhost:8000/api/github/repos/${repo.owner.login}/${repo.name}/commits`,
        {
          headers: { Authorization: `token ${token}` },
          params: { per_page: 100 } // Get more commits for detailed analysis
        }
      );
      
      const analysisRes = await axios.post(
        'http://localhost:8000/api/commits/analyze-json',
        {
          commits: response.data.map(commit => ({
            id: commit.sha,
            message: commit.commit.message
          }))
        },
        {
          headers: { Authorization: `token ${token}` }
        }
      );
      
      setAnalysis(analysisRes.data);
    } catch (err) {
      setError(err.response?.data?.detail || 'Failed to analyze commits');
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    if (visible) {
      fetchFullAnalysis();
    }
  }, [visible]);

  const criticalPercentage = analysis 
    ? Math.round((analysis.critical / analysis.total) * 100) 
    : 0;

  return (
    <Modal
      title={<><BarChartOutlined /> Commit Analysis for {repo.name}</>}
      visible={visible}
      onCancel={onCancel}
      footer={null}
      width={800}
    >
      {loading && <Spin size="large" style={{ display: 'block', margin: '40px auto' }} />}
      
      {error && (
        <Alert 
          message="Error" 
          description={error} 
          type="error" 
          showIcon 
          style={{ marginBottom: 20 }}
        />
      )}
      
      {analysis && (
        <Tabs defaultActiveKey="1">
          <TabPane tab={<><FileTextOutlined /> Commits</>} key="1">
            <div style={{ marginBottom: 20 }}>
              <div style={{ display: 'flex', alignItems: 'center', marginBottom: 16 }}>
                <Progress
                  type="circle"
                  percent={criticalPercentage}
                  width={80}
                  format={percent => (
                    <Text strong style={{ fontSize: 24, color: percent > 0 ? '#f5222d' : '#52c41a' }}>
                      {percent}%
                    </Text>
                  )}
                  status={criticalPercentage > 0 ? 'exception' : 'success'}
                />
                <div style={{ marginLeft: 20 }}>
                  <Title level={4} style={{ marginBottom: 0 }}>
                    {analysis.critical} of {analysis.total} commits are critical
                  </Title>
                  <Text type="secondary">
                    {criticalPercentage > 0 
                      ? 'This repository contains potentially critical changes'
                      : 'No critical commits detected'}
                  </Text>
                </div>
              </div>
              
              <List
                size="large"
                dataSource={analysis.details}
                renderItem={item => (
                  <List.Item>
                    <div style={{ width: '100%' }}>
                      <div style={{ display: 'flex', justifyContent: 'space-between' }}>
                        <Tag color={item.is_critical ? 'error' : 'success'}>
                          {item.is_critical ? 'CRITICAL' : 'Normal'}
                        </Tag>
                        <Text type="secondary" copyable>
                          {item.id.substring(0, 7)}
                        </Text>
                      </div>
                      <Divider style={{ margin: '8px 0' }} />
                      <Text style={{ color: item.is_critical ? '#f5222d' : 'inherit' }}>
                        {item.message_preview}
                      </Text>
                    </div>
                  </List.Item>
                )}
              />
            </div>
          </TabPane>
          
          <TabPane tab={<><ExclamationCircleOutlined /> Critical Commits</>} key="2">
            {analysis.critical > 0 ? (
              <List
                dataSource={analysis.details.filter(c => c.is_critical)}
                renderItem={item => (
                  <List.Item>
                    <Alert
                      message="Critical Commit"
                      description={
                        <>
                          <Text strong style={{ display: 'block', marginBottom: 4 }}>
                            {item.message_preview}
                          </Text>
                          <Text type="secondary">Commit ID: {item.id.substring(0, 7)}</Text>
                        </>
                      }
                      type="error"
                      showIcon
                    />
                  </List.Item>
                )}
              />
            ) : (
              <div style={{ textAlign: 'center', padding: '40px 0' }}>
                <CheckCircleOutlined style={{ fontSize: 48, color: '#52c41a', marginBottom: 20 }} />
                <Title level={4} style={{ color: '#52c41a' }}>
                  No Critical Commits Found
                </Title>
                <Text type="secondary">
                  All analyzed commits appear to be normal changes
                </Text>
              </div>
            )}
          </TabPane>
        </Tabs>
      )}
    </Modal>
  );
};

export default CommitAnalysisModal;
```

### frontend\src\components\commits\CommitList.jsx
```jsx
import { useEffect, useState } from "react";
import { List, Avatar, Typography, Spin, message, Tooltip, Card, Tag, Pagination } from "antd";
import { GithubOutlined, BranchesOutlined, ClockCircleOutlined, UserOutlined } from '@ant-design/icons';
import axios from "axios";
import styled from "styled-components";

const { Title, Text } = Typography;

const CommitCard = styled(Card)`
  margin-bottom: 16px;
  border-radius: 8px;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
  transition: all 0.3s ease;
  
  &:hover {
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    transform: translateY(-2px);
  }
`;

const CommitHeader = styled.div`
  display: flex;
  justify-content: space-between;
  margin-bottom: 8px;
`;

const CommitMessage = styled.div`
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  font-weight: 500;
  
  &:hover {
    white-space: normal;
    overflow: visible;
  }
`;

const CommitMeta = styled.div`
  display: flex;
  align-items: center;
  gap: 12px;
  margin-top: 8px;
  color: #666;
  font-size: 13px;
`;

const PaginationContainer = styled.div`
  display: flex;
  justify-content: center;
  margin-top: 20px;
`;

const CommitList = ({ owner, repo, branch }) => {
  const [commits, setCommits] = useState([]);
  const [loading, setLoading] = useState(true);
  const [currentPage, setCurrentPage] = useState(1);
  const pageSize = 5;

  useEffect(() => {
    if (!branch) return;

    const token = localStorage.getItem("access_token");
    if (!token) return;

    const fetchCommits = async () => {
      try {
        const response = await axios.get(
          `http://localhost:8000/api/github/${owner}/${repo}/commits?branch=${branch}`,
          {
            headers: {
              Authorization: `token ${token}`,
            },
          }
        );
        setCommits(response.data);
      } catch (err) {
        console.error(err);
        message.error("L·ªói khi l·∫•y danh s√°ch commit");
      } finally {
        setLoading(false);
      }
    };

    setLoading(true);
    fetchCommits();
  }, [owner, repo, branch]);

  const formatDate = (dateString) => {
    const options = { year: 'numeric', month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' };
    return new Date(dateString).toLocaleDateString('vi-VN', options);
  };

  // T√≠nh to√°n d·ªØ li·ªáu hi·ªÉn th·ªã theo trang hi·ªán t·∫°i
  const paginatedCommits = commits.slice(
    (currentPage - 1) * pageSize,
    currentPage * pageSize
  );

  if (loading) return <Spin tip="ƒêang t·∫£i commit..." size="large" />;

  return (
    <div style={{ padding: '16px' }}>
      <div style={{ display: 'flex', alignItems: 'center', marginBottom: '20px' }}>
        <Title level={4} style={{ margin: 0 }}>
          <BranchesOutlined style={{ marginRight: '8px', color: '#1890ff' }} />
          Commit tr√™n branch: <Tag color="blue">{branch}</Tag>
          <Tag style={{ marginLeft: '8px' }}>{commits.length} commits</Tag>
        </Title>
      </div>
      
      <List
        itemLayout="vertical"
        dataSource={paginatedCommits}
        renderItem={(item) => (
          <List.Item>
            <CommitCard>
              <CommitHeader>
                <Tooltip title={item.sha} placement="topLeft">
                  <Tag icon={<GithubOutlined />} color="default">
                    {item.sha.substring(0, 7)}
                  </Tag>
                </Tooltip>
              </CommitHeader>
              
              <CommitMessage>
                <Tooltip title={item.commit.message} placement="topLeft">
                  {item.commit.message.split('\n')[0]}
                </Tooltip>
              </CommitMessage>
              
              <CommitMeta>
                <div style={{ display: 'flex', alignItems: 'center' }}>
                  <Avatar 
                    src={item.author?.avatar_url} 
                    size="small" 
                    icon={<UserOutlined />}
                    style={{ marginRight: '8px' }}
                  />
                  <Text>{item.commit.author.name}</Text>
                </div>
                
                <div style={{ display: 'flex', alignItems: 'center' }}>
                  <ClockCircleOutlined style={{ marginRight: '4px' }} />
                  <Text>{formatDate(item.commit.author.date)}</Text>
                </div>
              </CommitMeta>
            </CommitCard>
          </List.Item>
        )}
      />

      <PaginationContainer>
        <Pagination
          current={currentPage}
          pageSize={pageSize}
          total={commits.length}
          onChange={(page) => setCurrentPage(page)}
          showSizeChanger={false}
          showQuickJumper
          style={{ marginTop: '20px' }}
        />
      </PaginationContainer>
    </div>
  );
};

export default CommitList;
```

### frontend\src\components\commits\CommitTable.jsx
```jsx
//frontend\src\components\commits\CommitTable.jsxCommitTable.jsx

import { useEffect, useState } from 'react';
import { Table } from 'antd';
import axios from 'axios';

const CommitTable = () => {
  const [commits, setCommits] = useState([]);

  useEffect(() => {
    const fetchCommits = async () => {
      try {
        const response = await axios.get('http://localhost:8000/commits');
        setCommits(response.data);
      } catch (error) {
        console.error('Failed to fetch commits:', error);
      }
    };
    fetchCommits();
  }, []);

  const columns = [
    {
      title: 'ID',
      dataIndex: 'id',
    },
    {
      title: 'Repo ID',
      dataIndex: 'repo_id',
    },
    {
      title: 'User ID',
      dataIndex: 'user_id',
    },
    {
      title: 'Message',
      dataIndex: 'message',
    },
    {
      title: 'Hash',
      dataIndex: 'commit_hash',
    },
    {
      title: 'Date',
      dataIndex: 'commit_date',
    },
  ];

  return (
    <div className="p-4">
      <h2 className="text-xl font-bold mb-4">L·ªãch s·ª≠ Commit</h2>
      <Table columns={columns} dataSource={commits} rowKey="id" />
    </div>
  );
};

export default CommitTable;
```

### frontend\src\components\Dashboard\AIInsightWidget.jsx
```jsx
import React from 'react';
import { Card, Space, Typography, Button, Tag } from 'antd';
import { BulbOutlined, WarningOutlined } from '@ant-design/icons';
import styled from 'styled-components';

const { Title, Text } = Typography;

// Styled components
const InsightContainer = styled(Card)`
  border-radius: 12px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
  background: #ffffff;
  transition: all 0.3s ease;

  &:hover {
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12);
    transform: translateY(-2px);
  }
`;

const InsightCard = styled(Card)`
  border-radius: 8px;
  border: 1px solid ${(props) => props.borderColor || '#f0f0f0'};
  background: #fff;
  transition: all 0.3s ease;
  padding: 12px;

  &:hover {
    border-color: ${(props) => props.borderColor || '#d9d9d9'};
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  }

  @media (max-width: 576px) {
    padding: 8px;
  }
`;

const IconWrapper = styled.div`
  display: flex;
  align-items: center;
  justify-content: center;
  width: 40px;
  height: 40px;
  border-radius: 50%;
  background: ${(props) => props.bgColor || '#f0f0f0'};
`;

const ActionWrapper = styled.div`
  display: flex;
  justify-content: flex-end;
  gap: 8px;

  @media (max-width: 576px) {
    justify-content: flex-start;
    margin-top: 8px;
  }
`;

const AIInsightWidget = () => {
  const insights = [
    {
      id: 1,
      type: 'suggestion',
      title: 'Ph√¢n c√¥ng ƒë·ªÅ xu·∫•t',
      description: 'Th√™m 2 developer v√†o repo "frontend" ƒë·ªÉ ƒë·∫£m b·∫£o deadline 25/04/2025.',
    },
    {
      id: 2,
      type: 'warning',
      title: 'D·ª± ƒëo√°n ti·∫øn ƒë·ªô',
      description: 'Repo "backend" c√≥ nguy c∆° tr·ªÖ h·∫°n 3 ng√†y. Xem x√©t tƒÉng t√†i nguy√™n.',
    },
  ];

  const getInsightStyle = (type) => {
    switch (type) {
      case 'suggestion':
        return {
          icon: <BulbOutlined style={{ fontSize: 20, color: '#1890ff' }} />,
          tag: <Tag color="blue">ƒê·ªÅ xu·∫•t</Tag>,
          borderColor: '#e6f7ff',
          iconBg: '#e6f7ff',
        };
      case 'warning':
        return {
          icon: <WarningOutlined style={{ fontSize: 20, color: '#fa8c16' }} />,
          tag: <Tag color="orange">C·∫£nh b√°o</Tag>,
          borderColor: '#fff7e6',
          iconBg: '#fff7e6',
        };
      default:
        return {
          icon: null,
          tag: null,
          borderColor: '#f0f0f0',
          iconBg: '#f0f0f0',
        };
    }
  };

  return (
    <InsightContainer
      title={<Title level={4} style={{ margin: 0 }}>G·ª£i √Ω AI</Title>}
      bordered={false}
    >
      <Space direction="vertical" size="middle" style={{ width: '100%' }}>
        {insights.map((item) => {
          const { icon, tag, borderColor, iconBg } = getInsightStyle(item.type);
          return (
            <InsightCard key={item.id} borderColor={borderColor}>
              <Space direction="horizontal" size="middle" style={{ width: '100%', alignItems: 'center' }}>
                <IconWrapper bgColor={iconBg}>{icon}</IconWrapper>
                <Space direction="vertical" size={4} style={{ flex: 1 }}>
                  <Space>
                    <Title level={5} style={{ margin: 0 }}>{item.title}</Title>
                    {tag}
                  </Space>
                  <Text type="secondary">{item.description}</Text>
                </Space>
                <ActionWrapper>
                  <Button type="primary" size="small">Th·ª±c hi·ªán</Button>
                  <Button size="small">B·ªè qua</Button>
                </ActionWrapper>
              </Space>
            </InsightCard>
          );
        })}
      </Space>
    </InsightContainer>
  );
};

export default AIInsightWidget;
```

### frontend\src\components\Dashboard\OverviewCard.jsx
```jsx
import React from 'react';
import { Card, Row, Col, Statistic } from 'antd';
import { ProjectOutlined, CheckCircleOutlined, WarningOutlined } from '@ant-design/icons';

const OverviewCard = ({ projects = 10, completedTasks = 50, overdueTasks = 5 }) => {
  return (
    <Card title="T·ªïng quan d·ª± √°n" bordered={false}>
      <Row gutter={16}>
        <Col span={8}>
          <Statistic
            title="S·ªë d·ª± √°n"
            value={projects}
            prefix={<ProjectOutlined />}
            valueStyle={{ color: '#1890ff' }}
          />
        </Col>
        <Col span={8}>
          <Statistic
            title="C√¥ng vi·ªác ho√†n th√†nh"
            value={completedTasks}
            prefix={<CheckCircleOutlined />}
            valueStyle={{ color: '#52c41a' }}
          />
        </Col>
        <Col span={8}>
          <Statistic
            title="C√¥ng vi·ªác tr·ªÖ h·∫°n"
            value={overdueTasks}
            prefix={<WarningOutlined />}
            valueStyle={{ color: '#ff4d4f' }}
          />
        </Col>
      </Row>
    </Card>
  );
};

export default OverviewCard;
```

### frontend\src\components\Dashboard\RepoListFilter.jsx
```jsx
import React, { useState } from 'react';
import { Card, Row, Col, Input, Select, Button } from 'antd';
import { SearchOutlined } from '@ant-design/icons';

const { Option } = Select;

const RepoListFilter = ({ onFilterChange }) => {
  const [searchText, setSearchText] = useState('');
  const [status, setStatus] = useState('all');
  const [assignee, setAssignee] = useState('all');

  const handleApplyFilter = () => {
    onFilterChange({ searchText, status, assignee });
  };

  return (
    <Card title="B·ªô l·ªçc Repository" bordered={false}>
      <Row gutter={16}>
        <Col span={8}>
          <Input
            placeholder="T√¨m ki·∫øm repo"
            prefix={<SearchOutlined />}
            value={searchText}
            onChange={(e) => setSearchText(e.target.value)}
          />
        </Col>
        <Col span={6}>
          <Select
            style={{ width: '100%' }}
            value={status}
            onChange={(value) => setStatus(value)}
            placeholder="Tr·∫°ng th√°i"
          >
            <Option value="all">T·∫•t c·∫£</Option>
            <Option value="active">ƒêang ho·∫°t ƒë·ªông</Option>
            <Option value="archived">ƒê√£ l∆∞u tr·ªØ</Option>
          </Select>
        </Col>
        <Col span={6}>
          <Select
            style={{ width: '100%' }}
            value={assignee}
            onChange={(value) => setAssignee(value)}
            placeholder="Ng∆∞·ªùi ph·ª• tr√°ch"
          >
            <Option value="all">T·∫•t c·∫£</Option>
            <Option value="user1">User 1</Option>
            <Option value="user2">User 2</Option>
          </Select>
        </Col>
        <Col span={4}>
          <Button type="primary" onClick={handleApplyFilter}>
            √Åp d·ª•ng
          </Button>
        </Col>
      </Row>
    </Card>
  );
};

export default RepoListFilter;
```

### frontend\src\components\Dashboard\TaskBoard.jsx
```jsx
import React, { useState } from 'react';
import { Card, Row, Col } from 'antd';
import { DndContext, closestCenter } from '@dnd-kit/core';
import { SortableContext, useSortable, arrayMove } from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';
import { Task } from '../../utils/types';

const SortableTask = ({ task }) => {
  const { attributes, listeners, setNodeRef, transform, transition } = useSortable({ id: task.id });

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
    marginBottom: 8,
  };

  return (
    <Card ref={setNodeRef} style={style} {...attributes} {...listeners}>
      <p>{task.title}</p>
      <p>Ng∆∞·ªùi ph·ª• tr√°ch: {task.assignee}</p>
    </Card>
  );
};

const TaskBoard = ({ initialTasks = [] }) => {
  const [tasks, setTasks] = useState(initialTasks);

  const onDragEnd = (event) => {
    const { active, over } = event;
    if (active.id !== over.id) {
      setTasks((items) => {
        const oldIndex = items.findIndex((item) => item.id === active.id);
        const newIndex = items.findIndex((item) => item.id === over.id);
        return arrayMove(items, oldIndex, newIndex);
      });
    }
  };

  const columns = {
    todo: { title: 'Ch·ªù x·ª≠ l√Ω', tasks: tasks.filter((task) => task.status === 'todo') },
    inProgress: { title: 'ƒêang th·ª±c hi·ªán', tasks: tasks.filter((task) => task.status === 'inProgress') },
    done: { title: 'Ho√†n th√†nh', tasks: tasks.filter((task) => task.status === 'done') },
  };

  return (
    <Card title="B·∫£ng c√¥ng vi·ªác" bordered={false}>
      <DndContext collisionDetection={closestCenter} onDragEnd={onDragEnd}>
        <Row gutter={16}>
          {Object.keys(columns).map((columnId) => (
            <Col span={8} key={columnId}>
              <Card title={columns[columnId].title} bordered={false}>
                <SortableContext items={columns[columnId].tasks.map((task) => task.id)}>
                  {columns[columnId].tasks.map((task) => (
                    <SortableTask key={task.id} task={task} />
                  ))}
                </SortableContext>
              </Card>
            </Col>
          ))}
        </Row>
      </DndContext>
    </Card>
  );
};

export default TaskBoard;
```

### frontend\src\components\repo\RepoList.jsx
```jsx
import { useEffect, useState } from "react";
import { Avatar, Typography, Spin, message, Card, Tag, Pagination } from "antd";
import { useNavigate } from "react-router-dom";
import { GithubOutlined, StarFilled, EyeFilled, ForkOutlined, CalendarOutlined } from "@ant-design/icons";
import styled from "styled-components";
import axios from "axios";

const { Title, Text } = Typography;

const RepoContainer = styled.div`
  max-width: 900px;
  margin: 0 auto;
  padding: 24px;
`;

const RepoCard = styled(Card)`
  margin-bottom: 20px;
  border-radius: 12px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
  transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
  cursor: pointer;
  border: none;
  
  &:hover {
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
    transform: translateY(-5px);
  }
`;

const RepoHeader = styled.div`
  display: flex;
  align-items: flex-start;
  margin-bottom: 12px;
`;

const RepoTitle = styled.div`
  flex: 1;
  min-width: 0;
`;

const RepoName = styled(Text)`
  display: block;
  font-size: 18px;
  font-weight: 600;
  color: #24292e;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
`;

const RepoDescription = styled(Text)`
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
  color: #586069;
  margin: 8px 0;
`;

const RepoMeta = styled.div`
  display: flex;
  flex-wrap: wrap;
  gap: 16px;
  margin-top: 16px;
  align-items: center;
`;

const MetaItem = styled.div`
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 14px;
  color: #586069;
`;

const StyledPagination = styled(Pagination)`
  margin-top: 32px;
  text-align: center;
  
  .ant-pagination-item-active {
    border-color: #1890ff;
    background: #1890ff;
    
    a {
      color: white;
    }
  }
`;

const HighlightTag = styled(Tag)`
  font-weight: 500;
  border-radius: 12px;
  padding: 0 10px;
`;

const RepoList = () => {
  const [repos, setRepos] = useState([]);
  const [loading, setLoading] = useState(true);
  const [currentPage, setCurrentPage] = useState(1);
  const [totalRepos, setTotalRepos] = useState(0);
  const navigate = useNavigate();
  const pageSize = 8;

  useEffect(() => {
    const fetchRepos = async () => {
      const token = localStorage.getItem("access_token");
      if (!token) return message.error("Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i!");

      try {
        setLoading(true);
        const response = await axios.get("http://localhost:8000/api/github/repos", {
          headers: { Authorization: `token ${token}` },
          params: { sort: 'updated', direction: 'desc' } // S·∫Øp x·∫øp theo m·ªõi nh·∫•t
        });
        
        // S·∫Øp x·∫øp l·∫°i ƒë·ªÉ ƒë·∫£m b·∫£o m·ªõi nh·∫•t l√™n ƒë·∫ßu
        const sortedRepos = response.data.sort((a, b) => 
          new Date(b.updated_at) - new Date(a.updated_at)
        );
        
        setRepos(sortedRepos);
        setTotalRepos(sortedRepos.length);
      } catch (error) {
        message.error("Kh√¥ng th·ªÉ t·∫£i danh s√°ch repository!");
        console.error(error);
      } finally {
        setLoading(false);
      }
    };

    fetchRepos();
  }, []);

  const formatDate = (dateString) => {
    return new Date(dateString).toLocaleDateString('vi-VN', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric'
    });
  };

  const paginatedRepos = repos.slice(
    (currentPage - 1) * pageSize,
    currentPage * pageSize
  );

  if (loading) {
    return (
      <div style={{ display: 'flex', justifyContent: 'center', marginTop: '100px' }}>
        <Spin tip="ƒêang t·∫£i d·ªØ li·ªáu..." size="large" />
      </div>
    );
  }

  return (
    <RepoContainer>
      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '24px' }}>
        <Title level={2} style={{ margin: 0, color: '#24292e' }}>
          <GithubOutlined style={{ marginRight: '12px', color: '#1890ff' }} />
          GitHub Repositories
        </Title>
        <Text strong style={{ fontSize: '16px' }}>
          T·ªïng c·ªông: {totalRepos} repositories
        </Text>
      </div>

      {paginatedRepos.map((repo) => (
        <RepoCard 
          key={repo.id} 
          onClick={() => navigate(`/repo/${repo.owner.login}/${repo.name}`)}
        >
          <RepoHeader>
            <Avatar 
              src={repo.owner.avatar_url} 
              size={48}
              style={{ marginRight: '16px', flexShrink: 0 }}
            />
            <RepoTitle>
              <div style={{ display: 'flex', alignItems: 'center' }}>
                <RepoName>{repo.name}</RepoName>
                {repo.private ? (
                  <HighlightTag color="error" style={{ marginLeft: '12px' }}>
                    Private
                  </HighlightTag>
                ) : (
                  <HighlightTag color="success" style={{ marginLeft: '12px' }}>
                    Public
                  </HighlightTag>
                )}
              </div>
              
              <RepoDescription type="secondary">
                {repo.description || "Kh√¥ng c√≥ m√¥ t·∫£"}
              </RepoDescription>
            </RepoTitle>
          </RepoHeader>

          <RepoMeta>
            <MetaItem>
              <StarFilled style={{ color: '#ffc53d' }} />
              <Text strong>{repo.stargazers_count}</Text>
              <Text>stars</Text>
            </MetaItem>
            
            <MetaItem>
              <EyeFilled style={{ color: '#1890ff' }} />
              <Text strong>{repo.watchers_count}</Text>
              <Text>watchers</Text>
            </MetaItem>
            
            <MetaItem>
              <ForkOutlined style={{ color: '#73d13d' }} />
              <Text strong>{repo.forks_count}</Text>
              <Text>forks</Text>
            </MetaItem>
            
            {repo.language && (
              <MetaItem>
                <div style={{
                  width: 12,
                  height: 12,
                  borderRadius: '50%',
                  backgroundColor: '#1890ff',
                  marginRight: 6
                }} />
                <Text>{repo.language}</Text>
              </MetaItem>
            )}
            
            <MetaItem style={{ marginLeft: 'auto' }}>
              <CalendarOutlined />
              <Text>C·∫≠p nh·∫≠t: {formatDate(repo.updated_at)}</Text>
            </MetaItem>
          </RepoMeta>
        </RepoCard>
      ))}

      <StyledPagination
        current={currentPage}
        pageSize={pageSize}
        total={totalRepos}
        onChange={(page) => setCurrentPage(page)}
        showSizeChanger={false}
        showQuickJumper
      />
    </RepoContainer>
  );
};

export default RepoList;
```

### frontend\src\features\github\GithubRepoFetcher.jsx
```jsx

```

### frontend\src\pages\AuthSuccess.jsx
```jsx
// src/pages/AuthSuccess.jsx
import React, { useEffect } from "react";
import { useNavigate, useLocation } from "react-router-dom";
import { message } from "antd";
import axios from "axios";

const AuthSuccess = () => {
  const navigate = useNavigate();
  const location = useLocation();

  useEffect(() => {
    const params = new URLSearchParams(location.search);
    const token = params.get("token");
    const username = params.get("username");
    const email = params.get("email");

    if (token) {
      const profile = {
        token,
        username,
        email,
        avatar_url: params.get("avatar_url"),
      };

      localStorage.setItem("github_profile", JSON.stringify(profile));
      localStorage.setItem("access_token", token);

      const syncAllRepositories = async () => {
        try {
          const response = await axios.get("http://localhost:8000/api/github/repos", {
            headers: {
              Authorization: `token ${token}`,
            },
          });

          const repositories = response.data;
          for (const repo of repositories) {
            await axios.post(
              `http://localhost:8000/api/github/${repo.owner.login}/${repo.name}/sync-all`,
              {},
              {
                headers: {
                  Authorization: `token ${token}`,
                },
              }
            );
          }

          message.success("ƒê·ªìng b·ªô d·ªØ li·ªáu th√†nh c√¥ng!");
        } catch (error) {
          console.error("L·ªói khi ƒë·ªìng b·ªô repository:", error);
          message.error("Kh√¥ng th·ªÉ ƒë·ªìng b·ªô repository!");
        }
      };

      syncAllRepositories();
      navigate("/dashboard");
    } else {
      navigate("/login");
    }
  }, [location, navigate]);

  return (
    <div className="h-screen flex items-center justify-center">
      <p className="text-xl">ƒêang ƒë·ªìng b·ªô d·ªØ li·ªáu...</p>
    </div>
  );
};

export default AuthSuccess;
```

### frontend\src\pages\Dashboard.jsx
```jsx
import React, { useEffect, useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { Button, Typography, Avatar, Card, Grid, Space, Divider, Badge, message, Spin } from 'antd';
import { LogoutOutlined, GithubOutlined, NotificationOutlined } from '@ant-design/icons';
import styled from 'styled-components';
import RepoList from '../components/repo/RepoList';
import OverviewCard from '../components/Dashboard/OverviewCard';
import AIInsightWidget from '../components/Dashboard/AIInsightWidget';
import RepoListFilter from '../components/Dashboard/RepoListFilter';
import TaskBoard from '../components/Dashboard/TaskBoard';
import axios from 'axios';

const { Title, Text } = Typography;
const { useBreakpoint } = Grid;

// Styled components v·ªõi theme hi·ªán ƒë·∫°i
const DashboardContainer = styled.div`
  padding: 24px;
  max-width: 1440px;
  margin: 0 auto;
  background: #f8fafc;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  gap: 24px;

  @media (max-width: 768px) {
    padding: 16px;
    gap: 16px;
  }
`;

const HeaderCard = styled(Card)`
  border-radius: 16px;
  background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
  border: 1px solid #e2e8f0;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.02);
  
  .ant-card-body {
    padding: 24px;
  }
`;

const DashboardCard = styled(Card)`
  border-radius: 16px;
  border: 1px solid #e2e8f0;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.02);
  transition: all 0.2s cubic-bezier(0.645, 0.045, 0.355, 1);
  
  &:hover {
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
    transform: translateY(-2px);
  }

  .ant-card-head {
    border-bottom: 1px solid #f1f5f9;
    padding: 16px 24px;
  }

  .ant-card-body {
    padding: 24px;
  }

  @media (max-width: 768px) {
    .ant-card-body {
      padding: 16px;
    }
  }
`;

const PrimaryButton = styled(Button)`
  border-radius: 8px;
  font-weight: 500;
  height: 40px;
  padding: 0 20px;
  display: flex;
  align-items: center;
  gap: 8px;
`;

const UserInfoContainer = styled.div`
  display: flex;
  align-items: center;
  gap: 16px;
`;

const UserAvatar = styled(Avatar)`
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
  border: 2px solid #ffffff;
`;

const WidgetsRow = styled.div`
  display: grid;
  grid-template-columns: 1.5fr 1fr;
  gap: 24px;

  @media (max-width: 992px) {
    grid-template-columns: 1fr;
  }
`;

const ContentSection = styled.section`
  display: flex;
  flex-direction: column;
  gap: 24px;
`;

const SectionTitle = styled(Title)`
  margin-bottom: 0 !important;
  font-weight: 600 !important;
  color: #1e293b !important;
  display: flex;
  align-items: center;
  gap: 8px;
`;

const NotificationBadge = styled(Badge)`
  .ant-badge-count {
    background: #3b82f6;
    box-shadow: 0 0 0 1px #fff;
  }
`;

const Dashboard = () => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(false);
  const navigate = useNavigate();
  const screens = useBreakpoint();

  const syncAllRepositories = async () => {
    const token = localStorage.getItem('access_token');
    if (!token) {
      message.error('Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i!');
      return;
    }

    try {
      setLoading(true);
      const response = await axios.get('http://localhost:8000/api/github/repos', {
        headers: {
          Authorization: `token ${token}`,
        },
      });

      const repositories = response.data;
      for (const repo of repositories) {
        await axios.post(
          `http://localhost:8000/api/github/${repo.owner.login}/${repo.name}/sync-all`,
          {},
          {
            headers: {
              Authorization: `token ${token}`,
            },
          }
        );
      }

      message.success('ƒê·ªìng b·ªô t·∫•t c·∫£ repository th√†nh c√¥ng!');
    } catch (error) {
      console.error('L·ªói khi ƒë·ªìng b·ªô repository:', error);
      message.error('Kh√¥ng th·ªÉ ƒë·ªìng b·ªô repository!');
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    const storedProfile = localStorage.getItem('github_profile');
    if (!storedProfile) {
      navigate('/login');
    } else {
      setUser(JSON.parse(storedProfile));
    }
    syncAllRepositories();
  }, [navigate]);

  const handleLogout = () => {
    localStorage.removeItem('github_profile');
    localStorage.removeItem('access_token');
    navigate('/login');
  };

  const handleFilterChange = (filters) => {
    console.log('Applied filters:', filters);
  };

  const handleStatusChange = (taskId, newStatus) => {
    console.log(`Updated task ${taskId} status to ${newStatus}`);
  };

  if (loading) {
    return <Spin tip="ƒêang ƒë·ªìng b·ªô d·ªØ li·ªáu..." size="large" />;
  }

  return (
    <DashboardContainer>
      {/* Header Section */}
      <HeaderCard bordered={false}>
        <Space 
          direction={screens.md ? 'horizontal' : 'vertical'} 
          align={screens.md ? 'center' : 'start'}
          style={{ width: '100%', justifyContent: 'space-between' }}
        >
          <UserInfoContainer>
            <UserAvatar src={user?.avatar_url} size={screens.md ? 72 : 56} />
            <div>
              <Title level={4} style={{ margin: 0, color: '#1e293b' }}>
                Welcome back, {user?.username || 'User'}!
              </Title>
              <Text type="secondary" style={{ color: '#64748b' }}>
                {user?.email || 'No email provided'}
              </Text>
            </div>
          </UserInfoContainer>
          
          <Space size={screens.md ? 16 : 8}>
            <NotificationBadge count={3} size="small">
              <Button 
                icon={<NotificationOutlined />} 
                shape="circle" 
                style={{ border: 'none' }}
              />
            </NotificationBadge>
            <PrimaryButton 
              type="primary" 
              danger 
              onClick={handleLogout}
              icon={<LogoutOutlined />}
            >
              {screens.md ? 'Log Out' : ''}
            </PrimaryButton>
          </Space>
        </Space>
      </HeaderCard>

      {/* Overview Metrics */}
      <DashboardCard bodyStyle={{ padding: '16px' }}>
        <OverviewCard />
      </DashboardCard>

      {/* AI Insights and Filters */}
      <WidgetsRow>
        <DashboardCard 
          title={
            <SectionTitle level={5}>
              <GithubOutlined />
              Repository Analysis
            </SectionTitle>
          }
        >
          <AIInsightWidget />
        </DashboardCard>
        
        <DashboardCard 
          title={<SectionTitle level={5}>Filters & Settings</SectionTitle>}
        >
          <RepoListFilter onFilterChange={handleFilterChange} />
        </DashboardCard>
      </WidgetsRow>

      {/* Main Content Sections */}
      <ContentSection>
        <DashboardCard 
          title={
            <SectionTitle level={5}>
              My Repositories
              <Text type="secondary" style={{ fontSize: 14, marginLeft: 8 }}>
                (24 repositories)
              </Text>
            </SectionTitle>
          }
        >
          <RepoList />
        </DashboardCard>

        <DashboardCard 
          title={<SectionTitle level={5}>Project Tasks</SectionTitle>}
        >
          <TaskBoard onStatusChange={handleStatusChange} />
        </DashboardCard>
      </ContentSection>
    </DashboardContainer>
  );
};

export default Dashboard;
```

### frontend\src\pages\Login.jsx
```jsx
// src/pages/Login.jsx
import React from "react";
import { Button, Card, Typography } from "antd";
import { GithubOutlined } from "@ant-design/icons";

const { Title } = Typography;

const Login = () => {
  const handleGitHubLogin = () => {
    window.location.href = "http://localhost:8000/api/login"; // backend redirect to GitHub OAuth
  };

  return (
    <div className="h-screen flex items-center justify-center bg-gradient-to-br from-gray-100 to-white">
      <Card
        className="shadow-xl rounded-2xl w-full max-w-md"
        style={{ textAlign: "center", padding: "3rem 2rem" }}
      >
        <Title level={2} style={{ marginBottom: "2rem" }}>
          ƒêƒÉng nh·∫≠p v√†o <span style={{ color: "#1890ff" }}>TaskFlowAI</span>
        </Title>
        <Button
          type="primary"
          icon={<GithubOutlined />}
          size="large"
          onClick={handleGitHubLogin}
          style={{
            backgroundColor: "#000",
            borderColor: "#000",
            width: "100%",
          }}
        >
          ƒêƒÉng nh·∫≠p v·ªõi GitHub
        </Button>
      </Card>
    </div>
  );
};

export default Login;
```

### frontend\src\pages\RepoDetails.jsx
```jsx
import { useEffect, useState } from "react";
import { useParams } from "react-router-dom";
import { message, Spin, Button } from "antd";
import BranchSelector from "../components/Branchs/BranchSelector";
import CommitList from "../components/commits/CommitList";
import axios from "axios";

const RepoDetails = () => {
  const { owner, repo } = useParams();
  const [branch, setBranch] = useState("");
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    const syncAllData = async () => {
      const token = localStorage.getItem("access_token");
      if (!token) {
        message.error("Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i!");
        return;
      }

      try {
        setLoading(true);
        await axios.post(
          `http://localhost:8000/api/github/${owner}/${repo}/sync-all`,
          {},
          {
            headers: {
              Authorization: `token ${token}`,
            },
          }
        );
        message.success("ƒê·ªìng b·ªô d·ªØ li·ªáu th√†nh c√¥ng!");
      } catch (error) {
        console.error("L·ªói khi ƒë·ªìng b·ªô d·ªØ li·ªáu:", error);
        message.error("Kh√¥ng th·ªÉ ƒë·ªìng b·ªô d·ªØ li·ªáu!");
      } finally {
        setLoading(false);
      }
    };

    syncAllData();
  }, [owner, repo]);

  const saveCommits = async () => {
    const token = localStorage.getItem("access_token");
    if (!token) {
      message.error("Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i!");
      return;
    }

    try {
      await axios.post(
        `http://localhost:8000/api/github/${owner}/${repo}/save-commits`,
        { branch },
        {
          headers: {
            Authorization: `token ${token}`,
          },
        }
      );
      message.success("L∆∞u commit th√†nh c√¥ng!");
    } catch (error) {
      console.error("L·ªói khi l∆∞u commit:", error);
      message.error("Kh√¥ng th·ªÉ l∆∞u commit!");
    }
  };

  if (loading) {
    return <Spin tip="ƒêang ƒë·ªìng b·ªô d·ªØ li·ªáu..." size="large" />;
  }

  return (
    <div style={{ padding: 24 }}>
      <h2 style={{ fontWeight: "bold" }}>üìÅ Repository: {repo}</h2>
      <BranchSelector owner={owner} repo={repo} onBranchChange={setBranch} />
      <Button type="primary" onClick={saveCommits}>
        L∆∞u Commit
      </Button>
      <CommitList owner={owner} repo={repo} branch={branch} />
    </div>
  );
};

export default RepoDetails;
```

### frontend\src\utils\types.js
```js
export const Task = {
  id: '',
  title: '',
  assignee: '',
  status: '', // 'todo', 'inProgress', 'done'
};
```
